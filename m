Return-Path: <SRS0=lsTH=42=vger.kernel.org=git-owner@kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.0 (2014-02-07) on
	aws-us-west-2-korg-lkml-1.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-9.8 required=3.0 tests=HEADER_FROM_DIFFERENT_DOMAINS,
	INCLUDES_PATCH,MAILING_LIST_MULTI,SIGNED_OFF_BY,SPF_HELO_NONE,SPF_PASS,
	USER_AGENT_GIT autolearn=ham autolearn_force=no version=3.4.0
Received: from mail.kernel.org (mail.kernel.org [198.145.29.99])
	by smtp.lore.kernel.org (Postfix) with ESMTP id D9340C10F27
	for <git@archiver.kernel.org>; Mon,  9 Mar 2020 12:10:14 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id A894721D56
	for <git@archiver.kernel.org>; Mon,  9 Mar 2020 12:10:14 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726415AbgCIMKN (ORCPT <rfc822;git@archiver.kernel.org>);
        Mon, 9 Mar 2020 08:10:13 -0400
Received: from mta-07-4.privateemail.com ([68.65.122.27]:26312 "EHLO
        MTA-07-4.privateemail.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S1726402AbgCIMKN (ORCPT <rfc822;git@vger.kernel.org>);
        Mon, 9 Mar 2020 08:10:13 -0400
Received: from MTA-07.privateemail.com (localhost [127.0.0.1])
        by MTA-07.privateemail.com (Postfix) with ESMTP id 9303360052;
        Mon,  9 Mar 2020 08:10:10 -0400 (EDT)
Received: from localhost.localdomain (unknown [10.20.151.246])
        by MTA-07.privateemail.com (Postfix) with ESMTPA id 879F060050;
        Mon,  9 Mar 2020 12:10:09 +0000 (UTC)
From:   "i.Dark_Templar" <darktemplar@dark-templar-archives.net>
To:     Junio C Hamano <gitster@pobox.com>
Cc:     git@vger.kernel.org,
        "i.Dark_Templar" <darktemplar@dark-templar-archives.net>
Subject: [RFC PATCH v2 1/2] git-merge: add option to format default message using multiple lines
Date:   Mon,  9 Mar 2020 15:07:21 +0300
Message-Id: <20200309120722.4987-2-darktemplar@dark-templar-archives.net>
X-Mailer: git-send-email 2.24.1
In-Reply-To: <20200309120722.4987-1-darktemplar@dark-templar-archives.net>
References: <2f0417b3-9e9e-f0db-ab11-92dd7cd2b29a@dark-templar-archives.net>
 <20200309120722.4987-1-darktemplar@dark-templar-archives.net>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-Virus-Scanned: ClamAV using ClamSMTP
Sender: git-owner@vger.kernel.org
Precedence: bulk
List-ID: <git.vger.kernel.org>
X-Mailing-List: git@vger.kernel.org

If a lot of objects is merged at once, default commit message
could become one very long line, which might be inconvenient to read.
This change implements an option to change default autogenerated message
so it'd take multiple lines, but each line wouldn't be long.

An artificial example.

Original merge commit message:
    Merge branch 'branch_with_some_long_name_1', remote-tracking branch 'clone/remote_branch_with_some_name', tags 'some_tag' and 'some_other_tag'; commit 'ae46a39cead2b42282abce725e90b561c06e94ba'; commit '33d0281e0eeb2a5e9907ebedc230e28c46865092' into merge7

Multiline merge commit message:
    Merge 6 commits into merge8

    Following commits are merged:
    branch 'branch_with_some_long_name_1'
    remote-tracking branch 'clone/remote_branch_with_some_name'
    tag 'some_tag'
    tag 'some_other_tag'
    commit 'ae46a39cead2b42282abce725e90b561c06e94ba'
    commit '33d0281e0eeb2a5e9907ebedc230e28c46865092'

Signed-off-by: i.Dark_Templar <darktemplar@dark-templar-archives.net>
---
 Documentation/config/fmt-merge-msg.txt |   9 ++
 builtin/fmt-merge-msg.c                | 115 ++++++++++++++++++++++++-
 2 files changed, 122 insertions(+), 2 deletions(-)

diff --git a/Documentation/config/fmt-merge-msg.txt b/Documentation/config/fmt-merge-msg.txt
index c73cfa90b7..7aecf95b68 100644
--- a/Documentation/config/fmt-merge-msg.txt
+++ b/Documentation/config/fmt-merge-msg.txt
@@ -8,3 +8,12 @@ merge.log::
 	most the specified number of one-line descriptions from the
 	actual commits that are being merged.  Defaults to false, and
 	true is a synonym for 20.
+
+merge.usemultiline::
+	Switch merge commit message format to multiline format
+	if merged commits count is greater than or equal to specified
+	value. If specified value is zero or a negative one, this feature
+	is disabled.
+	When multiline commit message format is used, every merged commit
+	will be written using new line. This should ensure that commit message
+	wouldn't become one very long line when there are a lot of merged commits.
diff --git a/builtin/fmt-merge-msg.c b/builtin/fmt-merge-msg.c
index 736f666f64..191824c962 100644
--- a/builtin/fmt-merge-msg.c
+++ b/builtin/fmt-merge-msg.c
@@ -20,6 +20,7 @@ static const char * const fmt_merge_msg_usage[] = {
 };
 
 static int use_branch_desc;
+static int use_multiline = -1;
 
 int fmt_merge_msg_config(const char *key, const char *value, void *cb)
 {
@@ -32,6 +33,8 @@ int fmt_merge_msg_config(const char *key, const char *value, void *cb)
 			merge_log_config = DEFAULT_MERGE_LOG_LEN;
 	} else if (!strcmp(key, "merge.branchdesc")) {
 		use_branch_desc = git_config_bool(key, value);
+	} else if (!strcmp(key, "merge.usemultiline")) {
+		use_multiline = git_config_int(key, value);
 	} else {
 		return git_default_config(key, value, cb);
 	}
@@ -413,6 +416,39 @@ static void shortlog(const char *name,
 	string_list_clear(&subjects, 0);
 }
 
+static int fmt_merge_refs_count(void)
+{
+	int i = 0;
+	int j = 0;
+	int objects_count = 0;
+
+	for (i = 0; i < srcs.nr; i++) {
+		struct src_data *src_data = srcs.items[i].util;
+
+		if (src_data->head_status == 1) {
+			++objects_count;
+			continue;
+		}
+		if (src_data->head_status == 3) {
+			++objects_count;
+		}
+		for (j = 0; j < src_data->branch.nr; j++) {
+			++objects_count;
+		}
+		for (j = 0; j < src_data->r_branch.nr; j++) {
+			++objects_count;
+		}
+		for (j = 0; j < src_data->tag.nr; j++) {
+			++objects_count;
+		}
+		for (j = 0; j < src_data->generic.nr; j++) {
+			++objects_count;
+		}
+	}
+
+	return objects_count;
+}
+
 static void fmt_merge_msg_title(struct strbuf *out,
 				const char *current_branch)
 {
@@ -467,6 +503,68 @@ static void fmt_merge_msg_title(struct strbuf *out,
 		strbuf_addf(out, " into %s\n", current_branch);
 }
 
+static void fmt_merge_msg_title_multiline(struct strbuf *out,
+				const char *current_branch, int count)
+{
+	int i = 0;
+	int j = 0;
+
+	if (!strcmp("master", current_branch))
+		strbuf_addf(out, "Merge %d %s\n", count, (count == 1) ? "commit" : "commits");
+	else
+		strbuf_addf(out, "Merge %d %s into %s\n", count, (count == 1) ? "commit" : "commits", current_branch);
+
+	strbuf_addch(out, '\n');
+
+	if (count == 1)
+		strbuf_addstr(out, "Following commit is merged:\n");
+	else
+		strbuf_addstr(out, "Following commits are merged:\n");
+
+	for (i = 0; i < srcs.nr; i++) {
+		struct src_data *src_data = srcs.items[i].util;
+		int add_origin = 0;
+
+		if (src_data->head_status == 1) {
+			strbuf_addf(out, "%s\n", srcs.items[i].string);
+			continue;
+		}
+
+		add_origin = strcmp(".", srcs.items[i].string);
+
+		if (src_data->head_status == 3) {
+			if (!add_origin)
+				strbuf_addstr(out, "HEAD\n");
+			else
+				strbuf_addf(out, "HEAD of %s\n", srcs.items[i].string);
+		}
+		for (j = 0; j < src_data->branch.nr; j++) {
+			if (!add_origin)
+				strbuf_addf(out, "branch %s\n", src_data->branch.items[j].string);
+			else
+				strbuf_addf(out, "branch %s of %s\n", src_data->branch.items[j].string, srcs.items[i].string);
+		}
+		for (j = 0; j < src_data->r_branch.nr; j++) {
+			if (!add_origin)
+				strbuf_addf(out, "remote-tracking branch %s\n", src_data->r_branch.items[j].string);
+			else
+				strbuf_addf(out, "remote-tracking branch %s of %s\n", src_data->r_branch.items[j].string, srcs.items[i].string);
+		}
+		for (j = 0; j < src_data->tag.nr; j++) {
+			if (!add_origin)
+				strbuf_addf(out, "tag %s\n", src_data->tag.items[j].string);
+			else
+				strbuf_addf(out, "tag %s of %s\n", src_data->tag.items[j].string, srcs.items[i].string);
+		}
+		for (j = 0; j < src_data->generic.nr; j++) {
+			if (!add_origin)
+				strbuf_addf(out, "commit %s\n", src_data->generic.items[j].string);
+			else
+				strbuf_addf(out, "commit %s of %s\n", src_data->generic.items[j].string, srcs.items[i].string);
+		}
+	}
+}
+
 static void fmt_tag_signature(struct strbuf *tagbuf,
 			      struct strbuf *sig,
 			      const char *buf,
@@ -631,8 +729,21 @@ int fmt_merge_msg(struct strbuf *in, struct strbuf *out,
 			die("error in line %d: %.*s", i, len, p);
 	}
 
-	if (opts->add_title && srcs.nr)
-		fmt_merge_msg_title(out, current_branch);
+	if (opts->add_title && srcs.nr) {
+		if (use_multiline <= 0) {
+			fmt_merge_msg_title(out, current_branch);
+		} else {
+			int count;
+
+			count = fmt_merge_refs_count();
+
+			if (count >= use_multiline) {
+				fmt_merge_msg_title_multiline(out, current_branch, count);
+			} else {
+				fmt_merge_msg_title(out, current_branch);
+			}
+		}
+	}
 
 	if (origins.nr)
 		fmt_merge_msg_sigs(out);
-- 
2.24.1

