From: Michael Haggerty <mhagger@alum.mit.edu>
Subject: Re: I have end-of-lifed cvsps
Date: Thu, 19 Dec 2013 10:31:37 +0100
Message-ID: <52B2BCF9.5080300@alum.mit.edu>
References: <20131212001738.996EB38055C@snark.thyrsus.com> <CACPiFCK+Z7dOfO2v29PMKz+Y_fH1++xqMuTquSQ84d8KyjjFeQ@mail.gmail.com> <20131212042624.GB8909@thyrsus.com> <CACPiFC+bopf32cgDcQcVpL5vW=3KxmSP8Oh1see4KduQ1BNcPw@mail.gmail.com> <52B02DFF.5010408@gmail.com> <CALKQrgf3kuXRpbWmSp_nk8+zDFYNzkgV+dSBHaBbmUkxqjaDUA@mail.gmail.com> <20131217145809.GC15010@thyrsus.com> <CALKQrgeegcsO7YVqEmQxD4=HfR4eitodAov0tEh7MRvBxtRKUA@mail.gmail.com> <20131217184724.GA17709@thyrsus.com> <52B2335D.2030607@alum.mit.edu> <CALKQrgdin=8h9dr=h+VfGjX3suOGRXNsvzzcF=_L9cQDYtKPgg@mail.gmail.com>
Mime-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 7bit
Cc: Eric Raymond <esr@thyrsus.com>,
	=?UTF-8?B?SmFrdWIgTmFyxJlic2tp?= <jnareb@gmail.com>,
	Martin Langhoff <martin.langhoff@gmail.com>,
	Git Mailing List <git@vger.kernel.org>
To: Johan Herland <johan@herland.net>
X-From: git-owner@vger.kernel.org Thu Dec 19 10:31:53 2013
Return-path: <git-owner@vger.kernel.org>
Envelope-to: gcvg-git-2@plane.gmane.org
Received: from vger.kernel.org ([209.132.180.67])
	by plane.gmane.org with esmtp (Exim 4.69)
	(envelope-from <git-owner@vger.kernel.org>)
	id 1VtZxQ-0001fp-Us
	for gcvg-git-2@plane.gmane.org; Thu, 19 Dec 2013 10:31:53 +0100
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751627Ab3LSJbs (ORCPT <rfc822;gcvg-git-2@m.gmane.org>);
	Thu, 19 Dec 2013 04:31:48 -0500
Received: from alum-mailsec-scanner-3.mit.edu ([18.7.68.14]:61049 "EHLO
	alum-mailsec-scanner-3.mit.edu" rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751328Ab3LSJbn (ORCPT
	<rfc822;git@vger.kernel.org>); Thu, 19 Dec 2013 04:31:43 -0500
X-AuditID: 1207440e-b7fbc6d000004ad9-2b-52b2bcfe45e4
Received: from outgoing-alum.mit.edu (OUTGOING-ALUM.MIT.EDU [18.7.68.33])
	by alum-mailsec-scanner-3.mit.edu (Symantec Messaging Gateway) with SMTP id A2.05.19161.EFCB2B25; Thu, 19 Dec 2013 04:31:42 -0500 (EST)
Received: from [192.168.69.148] (p57A24715.dip0.t-ipconnect.de [87.162.71.21])
	(authenticated bits=0)
        (User authenticated as mhagger@ALUM.MIT.EDU)
	by outgoing-alum.mit.edu (8.13.8/8.12.4) with ESMTP id rBJ9VcWP011538
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=NOT);
	Thu, 19 Dec 2013 04:31:40 -0500
User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:17.0) Gecko/20131005 Icedove/17.0.9
In-Reply-To: <CALKQrgdin=8h9dr=h+VfGjX3suOGRXNsvzzcF=_L9cQDYtKPgg@mail.gmail.com>
X-Enigmail-Version: 1.6
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFtrGKsWRmVeSWpSXmKPExsUixO6iqPtvz6Ygg48/mC2ubvGx6LrSzWSx
	4uocZot5d3cxWWxcZ+LA6rFz1l12j0svv7N5LPvayeLxeZNcAEsUt01SYklZcGZ6nr5dAndG
	/+YH7AWrzSumTjzO3MC4X6eLkZNDQsBEovXFMUYIW0ziwr31bF2MXBxCApcZJe5MW8wE4Zxj
	knj35z1YFa+AtsTMxjdsIDaLgKpE24QrzCA2m4CuxKKeZiYQW1QgSOLRoYfsEPWCEidnPmEB
	sUWA6nc8/gW2gVngJKPEj703wZqFBdQknj1dxQixbR+LxMJHL8E6OAUCJTafvwFUxAF0n7hE
	T2MQiMksoC6xfp4QSAWzgLzE9rdzmCcwCs5Csm4WQtUsJFULGJlXMcol5pTm6uYmZuYUpybr
	Ficn5uWlFuka6+VmluilppRuYoSEO98Oxvb1MocYBTgYlXh4V7zcGCTEmlhWXJl7iFGSg0lJ
	lNd496YgIb6k/JTKjMTijPii0pzU4kOMEhzMSiK8iiA53pTEyqrUonyYlDQHi5I4r9oSdT8h
	gfTEktTs1NSC1CKYrAwHh5IE716QRsGi1PTUirTMnBKENBMHJ8hwLimR4tS8lNSixNKSjHhQ
	BMcXA2MYJMUDtPce2N7igsRcoChE6ylGXY55Xz58YxRiycvPS5US5+0DKRIAKcoozYNbAUtu
	rxjFgT4W5l0KUsUDTIxwk14BLWECWmK8FmxJSSJCSqqBMSumryB6J7ur7DnGHd/N7S7Om1pX
	3dqYuGYCb47R9KtRL2QW/1xbKKWWIXQrd+NBuz1Vf37bcCTeCAzVa9NZ9iGppnbV 
Sender: git-owner@vger.kernel.org
Precedence: bulk
List-ID: <git.vger.kernel.org>
X-Mailing-List: git@vger.kernel.org
Archived-At: <http://permalink.gmane.org/gmane.comp.version-control.git/239517>

On 12/19/2013 02:11 AM, Johan Herland wrote:
> On Thu, Dec 19, 2013 at 12:44 AM, Michael Haggerty <mhagger@alum.mit.edu> wrote:
>> A correct incremental converter could be done (as long as the CVS users
>> don't literally change history retroactively) but it would be a lot of work.
> 
> Although I agree with that sentence as it is stated, I also believe
> that the parenthesized condition rules out a _majority_ of CVS repo of
> non-trivial size/history. So even though a correct incremental
> converter could be built, it would be pretty much useless if it did
> not gracefully handle rewritten history. And in the face of rewritten
> history it becomes pretty much impossible to define what a "correct"
> conversion should even look like (not to mention the difficulty of
> actually implementing that converter...).

A correct conversion would, conceptually, take a diff between the old
CVS history and the new CVS history (I'm talking about the history as a
whole, not a diff between two changesets), figure out what had changed,
and then figure out what Git commits to make to effect the same
conceptual changes in Git-land.

This means that the final Git history would have to depend not only on
the current entirety of the CVS history, but also on what the CVS
history *was* during previous incremental imports and how the tool chose
to represent that history in Git the previous rounds.

There is a tradeoff here.  The smarter the tool is, the fewer
restrictions would have to be made on what people can do in CVS.  For
example, it wouldn't be unreasonable to impose a rule that people are
not allowed to move files within the CVS repository (e.g., to fake
move-file-with-history) after the CVS <-> Git bridge is in use.  (Abuses
of the history that occurred *before* the first incremental conversion,
on the other hand, wouldn't be a problem.)  If the user of the
incremental tool has *no* influence on how his colleagues use CVS, then
the tool would have to be very smart and/or the user would might
sometimes be forced to do another from-scratch conversion.

> Here are just a couple of things a CVS user can do (and that happened
> fairly regularly at my previous $dayjob) that would make life
> difficult for an incremental converter (and that also makes stable
> output from a non-incremental converter hard to solve in practice):
> 
>  - A user "deletes" $file from $branch by simply removing the $branch
> symbol on $file (cvs tag -B -d $branch $file). CVS stores no record of
> this. Many non-incremental importers will see $file as never having
> existed on $branch. An incremental importer starting from a previously
> converted state, must somehow deal with that previous state no longer
> existing from the POV of CVS.

No problem; the tool could just add a synthetic commit "git rm"ming the
file from the branch.  It wouldn't know *when* the file was deleted, so
it would have to pick a plausible date between the time of the last
incremental conversion and the one that discovers that the branch tag
has been removed from the file.  The resulting Git history would contain
more complete information than CVS's history.

>  - A user moves a release tag on a few files to include a late bugfix
> into an upcoming release (cvs tag -F -r $new_rev $tag $file). There
> might be no single point in time where the tagged state existed in the
> repo, it has become a "Frankentag". You could claim user error here,
> and that such shortcuts should not happen, but that doesn't really
> prevent it from ever happening. Recreating the tree state of the
> Frankentag in Git is easy, but what kind of history do you construct
> to lead up to that tree?

Frankentags (tags that include file versions that didn't occur
contemporaneously) can occur even with one-time CVS->Git conversions.
The only way to handle them is to create a Git branch representing the
tag and base it at a plausible Git commit, and then (on the branch)
issue a fixup commit that makes the contents of the branch equal to the
contents of the CVS branch.  This is a problem that cvs2git already handles.

A hypothetical incremental importer would have to notice the changes in
the branch contents between the previous conversion and the current one,
and create commits on the branch to bring it in line with the current
contents.  This is no uglier than what a one-shot conversion already has
to do.

>  - A modularized project develops code on HEAD, and make regular
> releases of each module by tagging the files in the module dir with
> "$modulename-$version". Afterwards a project-wide "stable" tag is
> moved on that subset of files to include the new module release into
> the "stable" tag. ("stable" is conceptually a branch, but the CVS
> mechanism used here is still the tag, since CVS branches cannot
> "follow" eachother like in Git). This is pretty much the same
> Frankentag scenario as above, except that in this case it might be
> considered Best Practice (it was at our $dayjob), and not a
> shortcut/user error made by a single user.

Same problem and same solution as above, as far as I can see.

> (None of these examples even involve the "cvs admin" which allows you
> to do some truly scary and demented things to your CVS history...)

Even some of these might be permitted.  For example:

* Obsoleting already-converted revisions: it's a pretty stupid thing to
do in most cases and the tool could just ignore such events, retaining
the history in Git.  If the revisions were obsoleted because they
contained proprietary information or something, then you've got a bigger
problem on your hands but one that you would have even if you were using
pure Git.

* Retroactive changes to log messages: would probably have to be ignored
or handled via notes.

* Changes to the "default branch" (another brain-dead CVS feature
related to vendor branches): I'd have to think about it.  But handling
vendor branches is already difficult for a one-time converter because
CVS retains too little info (but cvs2git does it except in the most
ambiguous cases).  An incremental importer would have *more* information
than a one-shot importer, because it would have a hope of catching the
change to the default branch at roughly the time it occurred.

> My point here is that people will use whatever available tools they
> have to solve whatever problems they are currently having. And when
> CVS is your tool, you will sooner or later end up with a "solution"
> that irrevocably rewrites your CVS history.

Yes, but I maintain that an incremental importer could keep a Git
history that is consistent with the CVS history in the sense that:

1. the result of checking out any branch or tag, right after a run of
the importer, gives the same results as checking the same branch or tag
out of CVS.

2. the Git history from one run is added to (never rewritten) by the
next run.

Michael

-- 
Michael Haggerty
mhagger@alum.mit.edu
http://softwareswirl.blogspot.com/
