From: "Greg A. Woods" <woods@planix.com>
Subject: Re: "git merge" merges too much!
Date: Tue, 01 Dec 2009 13:52:18 -0500
Message-ID: <m1NFXpl-000knKC@most.weird.com>
References: <m1NEaLp-000kn1C@most.weird.com>
	<20091129051427.GA6104@coredump.intra.peff.net>
	<m1NFAji-000kn2C@most.weird.com>
	<20091130192212.GA23181@dpotapov.dyndns.org>
Reply-To: The Git Mailing List <git@vger.kernel.org>
Mime-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: multipart/signed;
 boundary="pgp-sign-Multipart_Tue_Dec__1_13:52:18_2009-1"; micalg=pgp-sha1;
 protocol="application/pgp-signature"
Content-Transfer-Encoding: 7bit
Cc: The Git Mailing List <git@vger.kernel.org>
To: Dmitry Potapov <dpotapov@gmail.com>
X-From: git-owner@vger.kernel.org Tue Dec 01 19:52:34 2009
Return-path: <git-owner@vger.kernel.org>
Envelope-to: gcvg-git-2@lo.gmane.org
Received: from vger.kernel.org ([209.132.176.167])
	by lo.gmane.org with esmtp (Exim 4.50)
	id 1NFXpu-0001O2-Gh
	for gcvg-git-2@lo.gmane.org; Tue, 01 Dec 2009 19:52:31 +0100
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752907AbZLASwT (ORCPT <rfc822;gcvg-git-2@m.gmane.org>);
	Tue, 1 Dec 2009 13:52:19 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1752302AbZLASwS
	(ORCPT <rfc822;git-outgoing>); Tue, 1 Dec 2009 13:52:18 -0500
Received: from most.robohack.planix.com ([204.92.254.2]:62053 "EHLO
	most.weird.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752132AbZLASwS (ORCPT <rfc822;git@vger.kernel.org>);
	Tue, 1 Dec 2009 13:52:18 -0500
Received: from once.weird.com
	([204.92.254.13] port=50544)
	by most.weird.com([204.92.254.2] port=25)
	via TCP with esmtp (6722 bytes)
	(sender: <woods@once.weird.com>)
	(ident <woods> using rfc1413)
	id <m1NFXpl-000knKC@most.weird.com>
	for <git@vger.kernel.org>;
	Tue, 1 Dec 2009 13:52:21 -0500 (EST)
	(Smail-3.2.0.122-Pre 2005-Nov-17 #1 built 2009-Feb-3)
In-Reply-To: <20091130192212.GA23181@dpotapov.dyndns.org>
User-Agent: Wanderlust/2.15.6 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.7 (=?ISO-8859-4?Q?Sanj=F2?=) APEL/10.7 Emacs/22.3
 (i386--netbsdelf) MULE/5.0 (SAKAKI)
X-Face: ;j3Eth2XV8h1Yfu<eXd9JL+"t;iT8?{X]Fjm`Qb]>*uL{<:dQ$#E[DB0gemGZJ"J#4fH*][
 lz;@-iwMv_u\6uIEKR0KY"=MzoQH#CrqBN`nG_5B@rrM8,f~Gr&h5a\=<t0loVf0$}bP=]i3OMh"n_
 _@m4/,~2`V=(-9LyW.)'`@E_fE^<4y7)BIe`A''/j-Y#gDNZERh%CCij'q-NA4F<|yjznEhd7=l^xH
 2.qD3o0IanGHERTW+z$G
Sender: git-owner@vger.kernel.org
Precedence: bulk
List-ID: <git.vger.kernel.org>
X-Mailing-List: git@vger.kernel.org
Archived-At: <http://permalink.gmane.org/gmane.comp.version-control.git/134246>

--pgp-sign-Multipart_Tue_Dec__1_13:52:18_2009-1
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: quoted-printable

At Mon, 30 Nov 2009 22:22:12 +0300, Dmitry Potapov <dpotapov@gmail.com> wro=
te:
Subject: Re: "git merge" merges too much!
>=20
> The key difference comparing to what you may got used is that branches
> are normally based on the oldest branch in what this feature may be
> included. Thus normally changes are not backported to old branches,
> because you can merge them directly.

Hmmm... the idea of creating topic branches based on the oldest branch
where the feature might be used is indeed neither intuitive, nor is it
mentioned anywhere I've so far read about using topic branches in Git.

To use topic branches effectively this way, especially in managing local
and custom changes to a large remote project where separate working
directories are needed for long-running builds, I think some additional
software configuration management tool must be used to create
"configuration" branches where all the desired change sets (topic
branches) are merged.

I spent half my dreaming time early this morning running through
scenarios of how to use topic branches, with true merging (not
re-basing), in a usable work-flow.

At the moment I'm leaning towards a process where the configuration
branch is re-created for every build -- i.e. the merges are redone from
every topic branch to a freshly configured branch forked from the
locally supported release branch, hopefully making use of git-rerere to
solve most conflicts in as automated a fashion as is possible.

This may not be a sane thing to do though -- it may be too much work to
do for every fix.  It somewhat goes against the current natural trend in
many of the projects I work on to develop changes on the trunk and then
back-port (some of) them to release branches.

Perhaps Stacked-Git really is the best answer.  I will have to
investigate more.


> > > Yes, you must cherry-pick or use rebase (which is a more featureful
> > > version of the pipeline you mentioned).
> >=20
> > "git rebase" will not work for me unless it grows a "copy" option ,
> > i.e. one which does not delete the original branch (i.e. avoids the
> > "reset" phase of its operation).
>=20
> There is no reset phase...

By "reset phase" I meant this part, from git-rebase(1):

       The current branch is reset to <upstream>, or <newbase> if the --onto
       option was supplied. This has the exact same effect as git reset --h=
ard
       <upstream> (or <newbase>).


> It is just reassigning the head of branch to
> point to a different commit-id. If you want to copy a branch instead of
> rebasing the old one, you create a new branch (a new name) that points
> to the same commit as the branch that you want to copy, after that you
> rebase this new branch. You can do that like this:
>=20
> $ git branch new-foo foo
>=20
> $ git rebase --onto newbase oldbase new-foo

Hmmm.... I'll have to think about that.  It makes some sense, but I
don't intuitively read the command-line parameters well enough to
predict the outcome in all of the scenarios I'm interested in.

what is "oldbase" there?  I'm guessing it means "base of foo" (and for
the moment, "new-foo" too)?

It's confusing because the manual page uses the word "upstream" to
describe this parameter.

=46rom my experiments it looks like what I might want to do to copy a
local branch to port its changes from one release branch to another is
something like this (where local-v2.0 is a branch with local changes
forked from release branch REL-v2.0, and I want to back-port these
changes to a new local branch forked from the release branch REL-v1.0):

	$ git branch local-base-v1.0 REL-v1.0	# mark base of new branch
	$ git branch local-v1.0 local-v2.0	# dup head of src branch
	$ git rebase --onto local-base-v1.0 REL-v2.0 local-v1.0
	$ git branch -d local-base-v1.0

The first and last steps may not be necessary if REL-v1.0 really is a
branch, but in my play project it is just a tag on the trunk.  In the
case that it were really already a branch then hopefully this would do:

	$ git branch local-v1.0 local-v2.0	# dup head of src branch
	$ git rebase --onto REL-v1.0 REL-v2.0 local-v1.0

The trick here seems to be to invent the name of the new branch based on
where it's going to be rebased to.

I think this does suffice very nicely as a "git copy" operation!


> The "copy" does not have the problem of rebase, but it has a different
> problem: You have two series of commits instead of one. If you found
> a bug in one of those commits, you will have to patch each series
> separately. Also, git merge may produce additional conflicts... So,
> copying commits is not something that I would recommend to do often.

Indeed.

--=20
						Greg A. Woods

+1 416 218-0098                VE3TCP          RoboHack <woods@robohack.ca>
Planix, Inc. <woods@planix.com>      Secrets of the Weird <woods@weird.com>

--pgp-sign-Multipart_Tue_Dec__1_13:52:18_2009-1
Content-Type: application/pgp-signature
Content-Transfer-Encoding: 7bit

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (NetBSD)

iD8DBQBLFWXiZn1xt3i/9H8RAjdNAKDCEwXdCzDhHkKojMoup7279/lajgCcDmYj
hgu1KFOuhyIthJrILrtE5iM=
=DaEz
-----END PGP SIGNATURE-----

--pgp-sign-Multipart_Tue_Dec__1_13:52:18_2009-1--
