From: "Greg A. Woods" <woods@planix.com>
Subject: Re: "git merge" merges too much!
Date: Tue, 01 Dec 2009 16:58:34 -0500
Message-ID: <m1NFak0-000kn2C@most.weird.com>
References: <m1NEaLp-000kn1C@most.weird.com>
	<20091129051427.GA6104@coredump.intra.peff.net>
	<m1NFAji-000kn2C@most.weird.com>
	<20091130192212.GA23181@dpotapov.dyndns.org>
	<m1NFXpl-000knKC@most.weird.com>
	<20091201205057.GD11235@dpotapov.dyndns.org>
Reply-To: The Git Mailing List <git@vger.kernel.org>
Mime-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: multipart/signed;
 boundary="pgp-sign-Multipart_Tue_Dec__1_16:58:30_2009-1"; micalg=pgp-sha1;
 protocol="application/pgp-signature"
Content-Transfer-Encoding: 7bit
To: The Git Mailing List <git@vger.kernel.org>
X-From: git-owner@vger.kernel.org Tue Dec 01 22:58:47 2009
Return-path: <git-owner@vger.kernel.org>
Envelope-to: gcvg-git-2@lo.gmane.org
Received: from vger.kernel.org ([209.132.176.167])
	by lo.gmane.org with esmtp (Exim 4.50)
	id 1NFak9-0000ai-Ii
	for gcvg-git-2@lo.gmane.org; Tue, 01 Dec 2009 22:58:45 +0100
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753351AbZLAV6c (ORCPT <rfc822;gcvg-git-2@m.gmane.org>);
	Tue, 1 Dec 2009 16:58:32 -0500
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1753319AbZLAV6c
	(ORCPT <rfc822;git-outgoing>); Tue, 1 Dec 2009 16:58:32 -0500
Received: from most.weird.com ([204.92.254.2]:60601 "EHLO most.weird.com"
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1753191AbZLAV6b (ORCPT <rfc822;git@vger.kernel.org>);
	Tue, 1 Dec 2009 16:58:31 -0500
Received: from once.weird.com
	([204.92.254.13] port=49351)
	by most.weird.com([204.92.254.2] port=25)
	via TCP with esmtp (7613 bytes)
	(sender: <woods@once.weird.com>)
	(ident <woods> using rfc1413)
	id <m1NFak0-000kn2C@most.weird.com>
	for <git@vger.kernel.org>;
	Tue, 1 Dec 2009 16:58:36 -0500 (EST)
	(Smail-3.2.0.122-Pre 2005-Nov-17 #1 built 2009-Feb-3)
In-Reply-To: <20091201205057.GD11235@dpotapov.dyndns.org>
User-Agent: Wanderlust/2.15.6 (Almost Unreal) SEMI/1.14.6 (Maruoka)
 FLIM/1.14.7 (=?ISO-8859-4?Q?Sanj=F2?=) APEL/10.7 Emacs/22.3
 (i386--netbsdelf) MULE/5.0 (SAKAKI)
X-Face: ;j3Eth2XV8h1Yfu<eXd9JL+"t;iT8?{X]Fjm`Qb]>*uL{<:dQ$#E[DB0gemGZJ"J#4fH*][
 lz;@-iwMv_u\6uIEKR0KY"=MzoQH#CrqBN`nG_5B@rrM8,f~Gr&h5a\=<t0loVf0$}bP=]i3OMh"n_
 _@m4/,~2`V=(-9LyW.)'`@E_fE^<4y7)BIe`A''/j-Y#gDNZERh%CCij'q-NA4F<|yjznEhd7=l^xH
 2.qD3o0IanGHERTW+z$G
Sender: git-owner@vger.kernel.org
Precedence: bulk
List-ID: <git.vger.kernel.org>
X-Mailing-List: git@vger.kernel.org
Archived-At: <http://permalink.gmane.org/gmane.comp.version-control.git/134258>

--pgp-sign-Multipart_Tue_Dec__1_16:58:30_2009-1
Content-Type: text/plain; charset=US-ASCII
Content-Transfer-Encoding: quoted-printable

At Tue, 1 Dec 2009 23:50:57 +0300, Dmitry Potapov <dpotapov@gmail.com> wrot=
e:
Subject: Re: "git merge" merges too much!
>=20
> > >=20
> > > $ git branch new-foo foo
> > >=20
> > > $ git rebase --onto newbase oldbase new-foo
> >=20
> > Hmmm.... I'll have to think about that.  It makes some sense, but I
> > don't intuitively read the command-line parameters well enough to
> > predict the outcome in all of the scenarios I'm interested in.
> >=20
> > what is "oldbase" there?  I'm guessing it means "base of foo" (and for
> > the moment, "new-foo" too)?
>=20
> You have:
>=20
>  o---o---o---o---o  newbase
>        \
>         o---o---o---o---o  oldbase
>                          \
>                           o---o---o  foo

Yes, sort of -- in the ideal situation, but not in my particular example
where "oldbase" is just a tag, not a real branch.

So yes, "oldbase" is in fact "base of foo".  Trickier still is when the
"oldbase" branch has one or more commits newer then "base of foo".  Does
Git not have a symbolic name for the true base of a branch?  I.e. is
there not some form of symbolic name for "N" in the following?

   o---o---o---o---o---o---o---o  master
            \
             o---o---N---o---o  release-1
                      \
                       o---o---o  local-release-1

(now of course if it is discovered that "release-1" has progressed since
the base of "foo" then "foo" should be rebased first, but perhaps there
is not time to do this before the other release has to be supported)


> and you want this:
>=20
>  o---o---o---o---o  newbase
>      |            \
>      |             o'--o'--o'  new-foo
>       \
>        o---o---o---o---o  oldbase
>                          \
>                           o---o---o  foo

Yes, sort of I suppose, if you trim all the non-relevant branches.

What I really want, I think, is something like this where at least the
non-relevant "master" branch is still shown:

                   1'--2'--3'  new-foo
                  /
         o---o---o  newbase
        /
   o---o---o---o---o---o---o---o  master
                \
                 o---o---o  oldbase
                          \
                           1---2---3  foo

Here's part of my confusion -- "newbase" as used above is actually older
than "oldbase".  :-) so ideally "oldbase" should always be described in
terms of "foo", not just given an arbitrary unrelated name.

Of course that doesn't rule out the following scenario either where
"newbase" really is newer than "oldbase" -- in my world a given project
might become locally supported first on either a newer release, or an
older release, so both above and below might happen:

                           1'--2'--3'  new-foo
                          /
                 o---o---o  newbase
                /
   o---o---o---o---o---o---o---o  master
        \
         o---o---o  oldbase
                  \
                   1---2---3  foo

And eventually I want to also merge whatever is still relevant from foo
to a "local" branch off master so that those changes can be sent
(usually as patches) upstream.

Sometimes I want to do development on a topic branch as close to the tip
of "master" so that it can most easily be pushed upstream, and then
back-port those changes to older release branches.

In fact the latter is exactly how I picture release branches to work in
normal development, and this is how several of the big projects I'd like
to get using Git are doing development (now usually with CVS).

Note too that in these kinds of projects "topic" branches are _always_
forked from the current tip of "master", long-running ones sometimes
rebased to keep up with "master", small fixes and changes are made
directly to the master branch; and small fixes, as well as relevant
features, sometimes those developed on "topic" branches, are back-ported
to release branches.

Note I'm not talking about ideals of best practises specific for Git
here -- I'm talking about actual working operational practises that
people are _very_ familiar with and which have been well proven using a
vast wide variety of different VCS's in the past.  For example I
seriously doubt any of the developers of the projects I'm thinking of
that I'd like to switch to using Git are ever going to want to fork
their topic branches from the oldest release branch base that they
intend to support, and many such projects will necessarily always have
at least a few long-running topic branches that will have to be
frequently rebased to keep up with the trunk so that their eventual
merging will go as smoothly as possible, and yet once any of these topic
branches is finally "closed" their changes may also have to be
back-ported to release branches.

To me the natural way to do these kinds of back-porting "merges" is to
restrict the merge to select only the commits on the branch, i.e. from
its base to its tip, thus the motivation for the topic of my thread (and
I think the motivation for the "What is the best way to backport a
feature?" thread as well).  I think if Git could do this kind of
"partial" merging directly without having to "copy" deltas with "rebase"
or "cherry-pick" or "am" or whatever, and thus create separate histories
for them, then it would be much better at supporting this traditional
practice of using branches to manage releases.  Without such ability it
truly does look as though some form of "patch" management tool is also a
necessary thing(evil?), as "rebase" and "cherry-pick" could quickly get
way out of control and be way too much work otherwise.

--=20
						Greg A. Woods
						Planix, Inc.

<woods@planix.com>       +1 416 218 0099        http://www.planix.com/

--pgp-sign-Multipart_Tue_Dec__1_16:58:30_2009-1
Content-Type: application/pgp-signature
Content-Transfer-Encoding: 7bit

-----BEGIN PGP SIGNATURE-----
Version: GnuPG v1.4.9 (NetBSD)

iD8DBQBLFZGGZn1xt3i/9H8RAiADAJ4rgVGO8qM085xUklmirA2/Pis+bACg1Fzd
ZABF4UMzWo8jQ3dVQOo5JlI=
=bzZA
-----END PGP SIGNATURE-----

--pgp-sign-Multipart_Tue_Dec__1_16:58:30_2009-1--
