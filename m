Return-Path: <git-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.2 (2018-09-13) on dcvr.yhbt.net
X-Spam-Level: 
X-Spam-ASN: AS31976 209.132.180.0/23
X-Spam-Status: No, score=-4.0 required=3.0 tests=AWL,BAYES_00,
	HEADER_FROM_DIFFERENT_DOMAINS,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	shortcircuit=no autolearn=ham autolearn_force=no version=3.4.2
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by dcvr.yhbt.net (Postfix) with ESMTP id 6E3891F803
	for <e@80x24.org>; Mon,  7 Jan 2019 08:37:59 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S1726540AbfAGIh6 (ORCPT <rfc822;e@80x24.org>);
        Mon, 7 Jan 2019 03:37:58 -0500
Received: from cloud.peff.net ([104.130.231.41]:56382 "HELO cloud.peff.net"
        rhost-flags-OK-OK-OK-OK) by vger.kernel.org with SMTP
        id S1725550AbfAGIh6 (ORCPT <rfc822;git@vger.kernel.org>);
        Mon, 7 Jan 2019 03:37:58 -0500
Received: (qmail 1564 invoked by uid 109); 7 Jan 2019 08:37:56 -0000
Received: from Unknown (HELO peff.net) (10.0.1.2)
 by cloud.peff.net (qpsmtpd/0.94) with SMTP; Mon, 07 Jan 2019 08:37:56 +0000
Authentication-Results: cloud.peff.net; auth=none
Received: (qmail 800 invoked by uid 111); 7 Jan 2019 08:37:34 -0000
Received: from sigill.intra.peff.net (HELO sigill.intra.peff.net) (10.0.0.7)
 by peff.net (qpsmtpd/0.94) with (ECDHE-RSA-AES256-GCM-SHA384 encrypted) SMTP; Mon, 07 Jan 2019 03:37:34 -0500
Authentication-Results: peff.net; auth=none
Received: by sigill.intra.peff.net (sSMTP sendmail emulation); Mon, 07 Jan 2019 03:37:54 -0500
Date:   Mon, 7 Jan 2019 03:37:54 -0500
From:   Jeff King <peff@peff.net>
To:     =?utf-8?B?UmVuw6k=?= Scharfe <l.s.r@web.de>
Cc:     git@vger.kernel.org, Junio C Hamano <gitster@pobox.com>,
        =?utf-8?B?w4Z2YXIgQXJuZmrDtnLDsA==?= Bjarmason <avarab@gmail.com>
Subject: [PATCH 07/11] convert has_sha1_file() callers to has_object_file()
Message-ID: <20190107083754.GG29431@sigill.intra.peff.net>
References: <20190107083150.GC21362@sigill.intra.peff.net>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
In-Reply-To: <20190107083150.GC21362@sigill.intra.peff.net>
Sender: git-owner@vger.kernel.org
Precedence: bulk
List-ID: <git.vger.kernel.org>
X-Mailing-List: git@vger.kernel.org

The only remaining callers of has_sha1_file() actually have an object_id
already. They can use the "object" variant, rather than dereferencing
the hash themselves.

The code changes here were completely generated by the included
coccinelle patch.

Signed-off-by: Jeff King <peff@peff.net>
---
 apply.c                            |  2 +-
 builtin/fetch.c                    |  7 +++----
 builtin/index-pack.c               |  2 +-
 builtin/reflog.c                   |  2 +-
 builtin/show-ref.c                 |  2 +-
 bulk-checkin.c                     |  2 +-
 cache-tree.c                       |  4 ++--
 contrib/coccinelle/object_id.cocci | 32 ++++++++++++++++++++++++++++++
 http-walker.c                      |  4 ++--
 refs.c                             |  2 +-
 send-pack.c                        |  2 +-
 sha1-file.c                        |  2 +-
 12 files changed, 47 insertions(+), 16 deletions(-)

diff --git a/apply.c b/apply.c
index 01793d6126..b8e257ead2 100644
--- a/apply.c
+++ b/apply.c
@@ -3183,7 +3183,7 @@ static int apply_binary(struct apply_state *state,
 		return 0; /* deletion patch */
 	}
 
-	if (has_sha1_file(oid.hash)) {
+	if (has_object_file(&oid)) {
 		/* We already have the postimage */
 		enum object_type type;
 		unsigned long size;
diff --git a/builtin/fetch.c b/builtin/fetch.c
index e0140327aa..57f35c6a0a 100644
--- a/builtin/fetch.c
+++ b/builtin/fetch.c
@@ -317,8 +317,7 @@ static void find_non_local_tags(const struct ref *refs,
 			    !has_object_file_with_flags(&ref->old_oid,
 							OBJECT_INFO_QUICK) &&
 			    !will_fetch(head, ref->old_oid.hash) &&
-			    !has_sha1_file_with_flags(item->oid.hash,
-						      OBJECT_INFO_QUICK) &&
+			    !has_object_file_with_flags(&item->oid, OBJECT_INFO_QUICK) &&
 			    !will_fetch(head, item->oid.hash))
 				oidclr(&item->oid);
 			item = NULL;
@@ -332,7 +331,7 @@ static void find_non_local_tags(const struct ref *refs,
 		 * fetch.
 		 */
 		if (item &&
-		    !has_sha1_file_with_flags(item->oid.hash, OBJECT_INFO_QUICK) &&
+		    !has_object_file_with_flags(&item->oid, OBJECT_INFO_QUICK) &&
 		    !will_fetch(head, item->oid.hash))
 			oidclr(&item->oid);
 
@@ -353,7 +352,7 @@ static void find_non_local_tags(const struct ref *refs,
 	 * checked to see if it needs fetching.
 	 */
 	if (item &&
-	    !has_sha1_file_with_flags(item->oid.hash, OBJECT_INFO_QUICK) &&
+	    !has_object_file_with_flags(&item->oid, OBJECT_INFO_QUICK) &&
 	    !will_fetch(head, item->oid.hash))
 		oidclr(&item->oid);
 
diff --git a/builtin/index-pack.c b/builtin/index-pack.c
index ac1f4ea9a7..31046c7a0a 100644
--- a/builtin/index-pack.c
+++ b/builtin/index-pack.c
@@ -772,7 +772,7 @@ static void sha1_object(const void *data, struct object_entry *obj_entry,
 	if (startup_info->have_repository) {
 		read_lock();
 		collision_test_needed =
-			has_sha1_file_with_flags(oid->hash, OBJECT_INFO_QUICK);
+			has_object_file_with_flags(oid, OBJECT_INFO_QUICK);
 		read_unlock();
 	}
 
diff --git a/builtin/reflog.c b/builtin/reflog.c
index 64a8df4f25..45e9e15006 100644
--- a/builtin/reflog.c
+++ b/builtin/reflog.c
@@ -94,7 +94,7 @@ static int tree_is_complete(const struct object_id *oid)
 	init_tree_desc(&desc, tree->buffer, tree->size);
 	complete = 1;
 	while (tree_entry(&desc, &entry)) {
-		if (!has_sha1_file(entry.oid->hash) ||
+		if (!has_object_file(entry.oid) ||
 		    (S_ISDIR(entry.mode) && !tree_is_complete(entry.oid))) {
 			tree->object.flags |= INCOMPLETE;
 			complete = 0;
diff --git a/builtin/show-ref.c b/builtin/show-ref.c
index ed888ffa48..6a706c02a6 100644
--- a/builtin/show-ref.c
+++ b/builtin/show-ref.c
@@ -23,7 +23,7 @@ static void show_one(const char *refname, const struct object_id *oid)
 	const char *hex;
 	struct object_id peeled;
 
-	if (!has_sha1_file(oid->hash))
+	if (!has_object_file(oid))
 		die("git show-ref: bad ref %s (%s)", refname,
 		    oid_to_hex(oid));
 
diff --git a/bulk-checkin.c b/bulk-checkin.c
index 409ecb566b..39ee7d6107 100644
--- a/bulk-checkin.c
+++ b/bulk-checkin.c
@@ -67,7 +67,7 @@ static int already_written(struct bulk_checkin_state *state, struct object_id *o
 	int i;
 
 	/* The object may already exist in the repository */
-	if (has_sha1_file(oid->hash))
+	if (has_object_file(oid))
 		return 1;
 
 	/* Might want to keep the list sorted */
diff --git a/cache-tree.c b/cache-tree.c
index 190c6e5aa6..47f3464a1f 100644
--- a/cache-tree.c
+++ b/cache-tree.c
@@ -225,7 +225,7 @@ int cache_tree_fully_valid(struct cache_tree *it)
 	int i;
 	if (!it)
 		return 0;
-	if (it->entry_count < 0 || !has_sha1_file(it->oid.hash))
+	if (it->entry_count < 0 || !has_object_file(&it->oid))
 		return 0;
 	for (i = 0; i < it->subtree_nr; i++) {
 		if (!cache_tree_fully_valid(it->down[i]->cache_tree))
@@ -253,7 +253,7 @@ static int update_one(struct cache_tree *it,
 
 	*skip_count = 0;
 
-	if (0 <= it->entry_count && has_sha1_file(it->oid.hash))
+	if (0 <= it->entry_count && has_object_file(&it->oid))
 		return it->entry_count;
 
 	/*
diff --git a/contrib/coccinelle/object_id.cocci b/contrib/coccinelle/object_id.cocci
index 6a7cf3e02d..73886ae583 100644
--- a/contrib/coccinelle/object_id.cocci
+++ b/contrib/coccinelle/object_id.cocci
@@ -147,3 +147,35 @@ expression E1, E2;
 - hashcmp(E1, E2) != 0
 + !hasheq(E1, E2)
   ...>}
+
+@@
+struct object_id OID;
+@@
+- has_sha1_file(OID.hash)
++ has_object_file(&OID)
+
+@@
+identifier f != has_object_file;
+struct object_id *OIDPTR;
+@@
+  f(...) {<...
+- has_sha1_file(OIDPTR->hash)
++ has_object_file(OIDPTR)
+  ...>}
+
+@@
+struct object_id OID;
+expression E;
+@@
+- has_sha1_file_with_flags(OID.hash, E)
++ has_object_file_with_flags(&OID, E)
+
+@@
+identifier f != has_object_file_with_flags;
+struct object_id *OIDPTR;
+expression E;
+@@
+  f(...) {<...
+- has_sha1_file_with_flags(OIDPTR->hash, E)
++ has_object_file_with_flags(OIDPTR, E)
+  ...>}
diff --git a/http-walker.c b/http-walker.c
index 29b59e2fe0..8ae5d76c6a 100644
--- a/http-walker.c
+++ b/http-walker.c
@@ -131,7 +131,7 @@ static int fill_active_slot(struct walker *walker)
 	list_for_each_safe(pos, tmp, head) {
 		obj_req = list_entry(pos, struct object_request, node);
 		if (obj_req->state == WAITING) {
-			if (has_sha1_file(obj_req->oid.hash))
+			if (has_object_file(&obj_req->oid))
 				obj_req->state = COMPLETE;
 			else {
 				start_object_request(walker, obj_req);
@@ -489,7 +489,7 @@ static int fetch_object(struct walker *walker, unsigned char *sha1)
 	if (obj_req == NULL)
 		return error("Couldn't find request for %s in the queue", hex);
 
-	if (has_sha1_file(obj_req->oid.hash)) {
+	if (has_object_file(&obj_req->oid)) {
 		if (obj_req->req != NULL)
 			abort_http_object_request(obj_req->req);
 		abort_object_request(obj_req);
diff --git a/refs.c b/refs.c
index f9936355cd..142888a40a 100644
--- a/refs.c
+++ b/refs.c
@@ -188,7 +188,7 @@ int ref_resolves_to_object(const char *refname,
 {
 	if (flags & REF_ISBROKEN)
 		return 0;
-	if (!has_sha1_file(oid->hash)) {
+	if (!has_object_file(oid)) {
 		error(_("%s does not point to a valid object!"), refname);
 		return 0;
 	}
diff --git a/send-pack.c b/send-pack.c
index f692686770..c673d3ed06 100644
--- a/send-pack.c
+++ b/send-pack.c
@@ -40,7 +40,7 @@ int option_parse_push_signed(const struct option *opt,
 
 static void feed_object(const struct object_id *oid, FILE *fh, int negative)
 {
-	if (negative && !has_sha1_file(oid->hash))
+	if (negative && !has_object_file(oid))
 		return;
 
 	if (negative)
diff --git a/sha1-file.c b/sha1-file.c
index 589a666686..449456f2ad 100644
--- a/sha1-file.c
+++ b/sha1-file.c
@@ -1372,7 +1372,7 @@ int pretend_object_file(void *buf, unsigned long len, enum object_type type,
 	struct cached_object *co;
 
 	hash_object_file(buf, len, type_name(type), oid);
-	if (has_sha1_file(oid->hash) || find_cached_object(oid))
+	if (has_object_file(oid) || find_cached_object(oid))
 		return 0;
 	ALLOC_GROW(cached_objects, cached_object_nr + 1, cached_object_alloc);
 	co = &cached_objects[cached_object_nr++];
-- 
2.20.1.470.g640a3e2614

