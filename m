From: Yasushi SHOJI <yashi@atmark-techno.com>
Subject: [PATCH] Rename git-merge-base to git-find-merge-base
Date: Sun, 11 Sep 2005 17:40:15 +0900
Message-ID: <87zmqk5768.wl@mail2.atmark-techno.com>
References: <7vr7c02zgg.fsf@assigned-by-dhcp.cox.net>
	<7virxbtder.fsf@assigned-by-dhcp.cox.net>
	<874q8s6q9w.wl@mail2.atmark-techno.com>
	<7v64t8xddr.fsf@assigned-by-dhcp.cox.net>
Mime-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
Cc: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Sun Sep 11 10:42:16 2005
Return-path: <git-owner@vger.kernel.org>
Received: from vger.kernel.org ([209.132.176.167])
	by ciao.gmane.org with esmtp (Exim 4.43)
	id 1EENNu-0001gc-MW
	for gcvg-git@gmane.org; Sun, 11 Sep 2005 10:40:23 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932373AbVIKIkU (ORCPT <rfc822;gcvg-git@m.gmane.org>);
	Sun, 11 Sep 2005 04:40:20 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S932406AbVIKIkU
	(ORCPT <rfc822;git-outgoing>); Sun, 11 Sep 2005 04:40:20 -0400
Received: from shop.atmark-techno.com ([210.191.215.173]:7377 "EHLO
	mail2.atmark-techno.com") by vger.kernel.org with ESMTP
	id S932373AbVIKIkT (ORCPT <rfc822;git@vger.kernel.org>);
	Sun, 11 Sep 2005 04:40:19 -0400
Received: from smtp.local-network (dns1.atmark-techno.com [210.191.215.170])
	by mail2.atmark-techno.com (Postfix) with ESMTP id 989EB2FA2;
	Sun, 11 Sep 2005 17:40:16 +0900 (JST)
Received: from wat.atmark-techno.com (unknown [192.168.10.81])
	by smtp.local-network (Postfix) with ESMTP id 2AE7DB61F;
	Sun, 11 Sep 2005 17:40:47 +0900 (JST)
To: Junio C Hamano <junkio@cox.net>
In-Reply-To: <7v64t8xddr.fsf@assigned-by-dhcp.cox.net>
User-Agent: Wanderlust/2.14.0
Sender: git-owner@vger.kernel.org
Precedence: bulk
X-Mailing-List: git@vger.kernel.org
Archived-At: <http://permalink.gmane.org/gmane.comp.version-control.git/8277>

Junio C Hamano wrote:
> 
> Yasushi SHOJI <yashi@atmark-techno.com> writes:
> 
> > I've already got used to it. but, at first, the name gave me the
> > impression that it merge the current branch with given base point.
> >
> > the current documentation says:
> >
> >    Finds as good a common ancestor as possible for a merge
> >
> > so would it be better to rename it to:
> >
> >    git-find-common-ancestor
> >
> > That's what the command does after all.
> 
> It does not find just any common ancestor, but tries to find a
> set of common ancestors that are good to be used as merge bases.
> So git-find-merge-base _might_ be an acceptable rename, but
> git-find-common-ancestor certainly isn't.

ok.  it certainly does't find all common ancestors for given sha1s.

how about renaming the command to git-find-merge-base as you suggested
and document what the merge base is?

attached patch does the rename only.  haven't added "merge base" entry
to Documentation/git-find-merge-base.txt.
--
       yashi

Rename git-merge-base to git-find-merge-base

The command is to _find_ merge base, not merge something with base.
Reflect what it does to its name.

Signed-off-by: Yasushi SHOJI <yashi@atmark-techno.com>


---

 .gitignore                            |    2 
 Documentation/git-find-merge-base.txt |   34 +++++++
 Documentation/git-merge-base.txt      |   34 -------
 Documentation/git-read-tree.txt       |    2 
 Documentation/git-show-branch.txt     |    2 
 Documentation/git.txt                 |    2 
 Makefile                              |    2 
 README                                |    2 
 find-merge-base.c                     |  171 +++++++++++++++++++++++++++++++++
 git-archimport.perl                   |    4 -
 git-fetch.sh                          |    2 
 git-merge-octopus.sh                  |    2 
 git-merge.sh                          |    2 
 git-octopus.sh                        |    2 
 git-resolve.sh                        |    4 -
 gitk                                  |    2 
 merge-base.c                          |  171 ---------------------------------
 t/t4100/t-apply-1.patch               |    2 
 t/t4100/t-apply-5.patch               |    2 
 templates/hooks--update               |    2 
 20 files changed, 223 insertions(+), 223 deletions(-)
 create mode 100644 Documentation/git-find-merge-base.txt
 delete mode 100644 Documentation/git-merge-base.txt
 create mode 100644 find-merge-base.c
 delete mode 100644 merge-base.c

2652b63c0dcd376f47e3985be26a3cef67c397c8
diff --git a/.gitignore b/.gitignore
--- a/.gitignore
+++ b/.gitignore
@@ -42,7 +42,7 @@ git-ls-tree
 git-mailinfo
 git-mailsplit
 git-merge
-git-merge-base
+git-find-merge-base
 git-merge-fredrik
 git-merge-index
 git-merge-octopus
diff --git a/Documentation/git-find-merge-base.txt b/Documentation/git-find-merge-base.txt
new file mode 100644
--- /dev/null
+++ b/Documentation/git-find-merge-base.txt
@@ -0,0 +1,34 @@
+git-find-merge-base(1)
+======================
+v0.1, May 2005
+
+NAME
+----
+git-find-merge-base - Finds as good a common ancestor as possible for a merge
+
+
+SYNOPSIS
+--------
+'git-find-merge-base' <commit> <commit>
+
+DESCRIPTION
+-----------
+"git-find-merge-base" finds as good a common ancestor as possible. Given a
+selection of equally good common ancestors it should not be relied on
+to decide in any particular way.
+
+The "git-find-merge-base" algorithm is still in flux - use the source...
+
+
+Author
+------
+Written by Linus Torvalds <torvalds@osdl.org>
+
+Documentation
+--------------
+Documentation by David Greaves, Junio C Hamano and the git-list <git@vger.kernel.org>.
+
+GIT
+---
+Part of the link:git.html[git] suite
+
diff --git a/Documentation/git-merge-base.txt b/Documentation/git-merge-base.txt
deleted file mode 100644
--- a/Documentation/git-merge-base.txt
+++ /dev/null
@@ -1,34 +0,0 @@
-git-merge-base(1)
-=================
-v0.1, May 2005
-
-NAME
-----
-git-merge-base - Finds as good a common ancestor as possible for a merge
-
-
-SYNOPSIS
---------
-'git-merge-base' <commit> <commit>
-
-DESCRIPTION
------------
-"git-merge-base" finds as good a common ancestor as possible. Given a
-selection of equally good common ancestors it should not be relied on
-to decide in any particular way.
-
-The "git-merge-base" algorithm is still in flux - use the source...
-
-
-Author
-------
-Written by Linus Torvalds <torvalds@osdl.org>
-
-Documentation
---------------
-Documentation by David Greaves, Junio C Hamano and the git-list <git@vger.kernel.org>.
-
-GIT
----
-Part of the link:git.html[git] suite
-
diff --git a/Documentation/git-read-tree.txt b/Documentation/git-read-tree.txt
--- a/Documentation/git-read-tree.txt
+++ b/Documentation/git-read-tree.txt
@@ -239,7 +239,7 @@ some edits since.  Three-way merge makes
 added or modified cache entries since $JC, and if you haven't,
 then does the right thing.  So with the following sequence:
 
-    $ git-read-tree -m -u `git-merge-base $JC $LT` $JC $LT
+    $ git-read-tree -m -u `git-find-merge-base $JC $LT` $JC $LT
     $ git-merge-index git-merge-one-file -a
     $ echo "Merge with Linus" | \
       git-commit-tree `git-write-tree` -p $JC -p $LT
diff --git a/Documentation/git-show-branch.txt b/Documentation/git-show-branch.txt
--- a/Documentation/git-show-branch.txt
+++ b/Documentation/git-show-branch.txt
@@ -38,7 +38,7 @@ OPTIONS
 
 --merge-base::
 	Instead of showing the commit list, just act like the
-	'git-merge-base -a' command, except that it can accept
+	'git-find-merge-base -a' command, except that it can accept
 	more than two heads.
 
 --independent::
diff --git a/Documentation/git.txt b/Documentation/git.txt
--- a/Documentation/git.txt
+++ b/Documentation/git.txt
@@ -131,7 +131,7 @@ link:git-ls-files.html[git-ls-files]::
 link:git-ls-tree.html[git-ls-tree]::
 	Displays a tree object in human readable form
 
-link:git-merge-base.html[git-merge-base]::
+link:git-find-merge-base.html[git-find-merge-base]::
 	Finds as good a common ancestor as possible for a merge
 
 link:git-rev-list.html[git-rev-list]::
diff --git a/Makefile b/Makefile
--- a/Makefile
+++ b/Makefile
@@ -98,7 +98,7 @@ PROGRAMS = \
 	git-diff-helper git-diff-index git-diff-stages \
 	git-diff-tree git-export git-fetch-pack git-fsck-objects \
 	git-hash-object git-init-db \
-	git-local-fetch git-ls-files git-ls-tree git-merge-base \
+	git-local-fetch git-ls-files git-ls-tree git-find-merge-base \
 	git-merge-index git-mktag git-pack-objects git-patch-id \
 	git-peek-remote git-prune-packed git-read-tree \
 	git-receive-pack git-rev-list git-rev-parse \
diff --git a/README b/README
--- a/README
+++ b/README
@@ -445,7 +445,7 @@ state of the directory ("tree" object) a
 To get the "base" for the merge, you first look up the common parent
 of two commits with
 
-		git-merge-base <commit1> <commit2>
+		git-find-merge-base <commit1> <commit2>
 
 which will return you the commit they are both based on.  You should
 now look up the "tree" objects of those commits, which you can easily
diff --git a/find-merge-base.c b/find-merge-base.c
new file mode 100644
--- /dev/null
+++ b/find-merge-base.c
@@ -0,0 +1,171 @@
+#include <stdlib.h>
+#include "cache.h"
+#include "commit.h"
+
+#define PARENT1 1
+#define PARENT2 2
+#define UNINTERESTING 4
+
+static struct commit *interesting(struct commit_list *list)
+{
+	while (list) {
+		struct commit *commit = list->item;
+		list = list->next;
+		if (commit->object.flags & UNINTERESTING)
+			continue;
+		return commit;
+	}
+	return NULL;
+}
+
+/*
+ * A pathological example of how this thing works.
+ *
+ * Suppose we had this commit graph, where chronologically
+ * the timestamp on the commit are A <= B <= C <= D <= E <= F
+ * and we are trying to figure out the merge base for E and F
+ * commits.
+ *
+ *                  F
+ *                 / \
+ *            E   A   D
+ *             \ /   /  
+ *              B   /
+ *               \ /
+ *                C
+ *
+ * First we push E and F to list to be processed.  E gets bit 1
+ * and F gets bit 2.  The list becomes:
+ *
+ *     list=F(2) E(1), result=empty
+ *
+ * Then we pop F, the newest commit, from the list.  Its flag is 2.
+ * We scan its parents, mark them reachable from the side that F is
+ * reachable from, and push them to the list:
+ *
+ *     list=E(1) D(2) A(2), result=empty
+ *
+ * Next pop E and do the same.
+ *
+ *     list=D(2) B(1) A(2), result=empty
+ *
+ * Next pop D and do the same.
+ *
+ *     list=C(2) B(1) A(2), result=empty
+ *
+ * Next pop C and do the same.
+ *
+ *     list=B(1) A(2), result=empty
+ *
+ * Now it is B's turn.  We mark its parent, C, reachable from B's side,
+ * and push it to the list:
+ *
+ *     list=C(3) A(2), result=empty
+ *
+ * Now pop C and notice it has flags==3.  It is placed on the result list,
+ * and the list now contains:
+ *
+ *     list=A(2), result=C(3)
+ *
+ * We pop A and do the same.
+ * 
+ *     list=B(3), result=C(3)
+ *
+ * Next, we pop B and something very interesting happens.  It has flags==3
+ * so it is also placed on the result list, and its parents are marked
+ * uninteresting, retroactively, and placed back on the list:
+ *
+ *    list=C(7), result=C(7) B(3)
+ * 
+ * Now, list does not have any interesting commit.  So we find the newest
+ * commit from the result list that is not marked uninteresting.  Which is
+ * commit B.
+ */
+
+static int show_all = 0;
+
+static int find_merge_base(struct commit *rev1, struct commit *rev2)
+{
+	struct commit_list *list = NULL;
+	struct commit_list *result = NULL;
+
+	if (rev1 == rev2) {
+		printf("%s\n", sha1_to_hex(rev1->object.sha1));
+		return 0;
+	}
+
+	parse_commit(rev1);
+	parse_commit(rev2);
+
+	rev1->object.flags |= 1;
+	rev2->object.flags |= 2;
+	insert_by_date(rev1, &list);
+	insert_by_date(rev2, &list);
+
+	while (interesting(list)) {
+		struct commit *commit = list->item;
+		struct commit_list *tmp = list, *parents;
+		int flags = commit->object.flags & 7;
+
+		list = list->next;
+		free(tmp);
+		if (flags == 3) {
+			insert_by_date(commit, &result);
+
+			/* Mark parents of a found merge uninteresting */
+			flags |= UNINTERESTING;
+		}
+		parents = commit->parents;
+		while (parents) {
+			struct commit *p = parents->item;
+			parents = parents->next;
+			if ((p->object.flags & flags) == flags)
+				continue;
+			parse_commit(p);
+			p->object.flags |= flags;
+			insert_by_date(p, &list);
+		}
+	}
+
+	if (!result)
+		return 1;
+
+	while (result) {
+		struct commit *commit = result->item;
+		result = result->next;
+		if (commit->object.flags & UNINTERESTING)
+			continue;
+		printf("%s\n", sha1_to_hex(commit->object.sha1));
+		if (!show_all)
+			return 0;
+		commit->object.flags |= UNINTERESTING;
+	}
+	return 0;
+}
+
+static const char find_merge_base_usage[] =
+"git-find-merge-base [--all] <commit-id> <commit-id>";
+
+int main(int argc, char **argv)
+{
+	struct commit *rev1, *rev2;
+	unsigned char rev1key[20], rev2key[20];
+
+	while (1 < argc && argv[1][0] == '-') {
+		char *arg = argv[1];
+		if (!strcmp(arg, "-a") || !strcmp(arg, "--all"))
+			show_all = 1;
+		else
+			usage(find_merge_base_usage);
+		argc--; argv++;
+	}
+	if (argc != 3 ||
+	    get_sha1(argv[1], rev1key) ||
+	    get_sha1(argv[2], rev2key))
+		usage(find_merge_base_usage);
+	rev1 = lookup_commit_reference(rev1key);
+	rev2 = lookup_commit_reference(rev2key);
+	if (!rev1 || !rev2)
+		return 1;
+	return find_merge_base(rev1, rev2);
+}
diff --git a/git-archimport.perl b/git-archimport.perl
--- a/git-archimport.perl
+++ b/git-archimport.perl
@@ -640,7 +640,7 @@ sub find_parents {
     #
     # Identify what branches are merging into me
     # and whether we are fully merged
-    # git-merge-base <headsha> <headsha> should tell
+    # git-find-merge-base <headsha> <headsha> should tell
     # me what the base of the merge should be 
     #
     my $ps = shift;
@@ -674,7 +674,7 @@ sub find_parents {
     # that branch.
     #
     foreach my $branch (keys %branches) {
-	my $mergebase = `git-merge-base $branch $ps->{branch}`;
+	my $mergebase = `git-find-merge-base $branch $ps->{branch}`;
 	die "Cannot find merge base for $branch and $ps->{branch}" if $?;
 	chomp $mergebase;
 
diff --git a/git-fetch.sh b/git-fetch.sh
--- a/git-fetch.sh
+++ b/git-fetch.sh
@@ -113,7 +113,7 @@ fast_forward_local () {
 	if test -f "$GIT_DIR/$1"
 	then
 	    local=$(git-rev-parse --verify "$1^0") &&
-	    mb=$(git-merge-base "$local" "$2") &&
+	    mb=$(git-find-merge-base "$local" "$2") &&
 	    case "$2,$mb" in
 	    $local,*)
 		echo >&2 "* $1: same as $3"
diff --git a/git-merge-octopus.sh b/git-merge-octopus.sh
--- a/git-merge-octopus.sh
+++ b/git-merge-octopus.sh
@@ -42,7 +42,7 @@ CNT=1 ;# counting our head
 NON_FF_MERGE=0
 for SHA1 in $remotes
 do
-	common=$(git-merge-base $MRC $SHA1) ||
+	common=$(git-find-merge-base $MRC $SHA1) ||
 		die "Unable to find common commit with $SHA1"
 
 	if test "$common" = $SHA1
diff --git a/git-merge.sh b/git-merge.sh
--- a/git-merge.sh
+++ b/git-merge.sh
@@ -114,7 +114,7 @@ case "$#,$common" in
 	up_to_date=t
 	for remote
 	do
-		common_one=$(git-merge-base $head $remote)
+		common_one=$(git-find-merge-base $head $remote)
 		if test "$common_one" != "$remote"
 		then
 			up_to_date=f
diff --git a/git-octopus.sh b/git-octopus.sh
--- a/git-octopus.sh
+++ b/git-octopus.sh
@@ -33,7 +33,7 @@ CNT=1 ;# counting our head
 NON_FF_MERGE=0
 while read SHA1 REPO
 do
-	common=$(git-merge-base $MRC $SHA1) ||
+	common=$(git-find-merge-base $MRC $SHA1) ||
 		die "Unable to find common commit with $SHA1 from $REPO"
 
 	if test "$common" = $SHA1
diff --git a/git-resolve.sh b/git-resolve.sh
--- a/git-resolve.sh
+++ b/git-resolve.sh
@@ -31,7 +31,7 @@ dropheads
 echo $head > "$GIT_DIR"/ORIG_HEAD
 echo $merge > "$GIT_DIR"/LAST_MERGE
 
-common=$(git-merge-base $head $merge)
+common=$(git-find-merge-base $head $merge)
 if [ -z "$common" ]; then
 	die "Unable to find common commit between" $merge $head
 fi
@@ -55,7 +55,7 @@ esac
 # Find an optimum merge base if there are more than one candidates.
 LF='
 '
-common=$(git-merge-base -a $head $merge)
+common=$(git-find-merge-base -a $head $merge)
 case "$common" in
 ?*"$LF"?*)
 	echo "Trying to find the optimum merge base."
diff --git a/gitk b/gitk
--- a/gitk
+++ b/gitk
@@ -2266,7 +2266,7 @@ proc findgca {ids} {
 	    set gca $id
 	} else {
 	    if {[catch {
-		set gca [exec git-merge-base $gca $id]
+		set gca [exec git-find-merge-base $gca $id]
 	    } err]} {
 		return {}
 	    }
diff --git a/merge-base.c b/merge-base.c
deleted file mode 100644
--- a/merge-base.c
+++ /dev/null
@@ -1,171 +0,0 @@
-#include <stdlib.h>
-#include "cache.h"
-#include "commit.h"
-
-#define PARENT1 1
-#define PARENT2 2
-#define UNINTERESTING 4
-
-static struct commit *interesting(struct commit_list *list)
-{
-	while (list) {
-		struct commit *commit = list->item;
-		list = list->next;
-		if (commit->object.flags & UNINTERESTING)
-			continue;
-		return commit;
-	}
-	return NULL;
-}
-
-/*
- * A pathological example of how this thing works.
- *
- * Suppose we had this commit graph, where chronologically
- * the timestamp on the commit are A <= B <= C <= D <= E <= F
- * and we are trying to figure out the merge base for E and F
- * commits.
- *
- *                  F
- *                 / \
- *            E   A   D
- *             \ /   /  
- *              B   /
- *               \ /
- *                C
- *
- * First we push E and F to list to be processed.  E gets bit 1
- * and F gets bit 2.  The list becomes:
- *
- *     list=F(2) E(1), result=empty
- *
- * Then we pop F, the newest commit, from the list.  Its flag is 2.
- * We scan its parents, mark them reachable from the side that F is
- * reachable from, and push them to the list:
- *
- *     list=E(1) D(2) A(2), result=empty
- *
- * Next pop E and do the same.
- *
- *     list=D(2) B(1) A(2), result=empty
- *
- * Next pop D and do the same.
- *
- *     list=C(2) B(1) A(2), result=empty
- *
- * Next pop C and do the same.
- *
- *     list=B(1) A(2), result=empty
- *
- * Now it is B's turn.  We mark its parent, C, reachable from B's side,
- * and push it to the list:
- *
- *     list=C(3) A(2), result=empty
- *
- * Now pop C and notice it has flags==3.  It is placed on the result list,
- * and the list now contains:
- *
- *     list=A(2), result=C(3)
- *
- * We pop A and do the same.
- * 
- *     list=B(3), result=C(3)
- *
- * Next, we pop B and something very interesting happens.  It has flags==3
- * so it is also placed on the result list, and its parents are marked
- * uninteresting, retroactively, and placed back on the list:
- *
- *    list=C(7), result=C(7) B(3)
- * 
- * Now, list does not have any interesting commit.  So we find the newest
- * commit from the result list that is not marked uninteresting.  Which is
- * commit B.
- */
-
-static int show_all = 0;
-
-static int merge_base(struct commit *rev1, struct commit *rev2)
-{
-	struct commit_list *list = NULL;
-	struct commit_list *result = NULL;
-
-	if (rev1 == rev2) {
-		printf("%s\n", sha1_to_hex(rev1->object.sha1));
-		return 0;
-	}
-
-	parse_commit(rev1);
-	parse_commit(rev2);
-
-	rev1->object.flags |= 1;
-	rev2->object.flags |= 2;
-	insert_by_date(rev1, &list);
-	insert_by_date(rev2, &list);
-
-	while (interesting(list)) {
-		struct commit *commit = list->item;
-		struct commit_list *tmp = list, *parents;
-		int flags = commit->object.flags & 7;
-
-		list = list->next;
-		free(tmp);
-		if (flags == 3) {
-			insert_by_date(commit, &result);
-
-			/* Mark parents of a found merge uninteresting */
-			flags |= UNINTERESTING;
-		}
-		parents = commit->parents;
-		while (parents) {
-			struct commit *p = parents->item;
-			parents = parents->next;
-			if ((p->object.flags & flags) == flags)
-				continue;
-			parse_commit(p);
-			p->object.flags |= flags;
-			insert_by_date(p, &list);
-		}
-	}
-
-	if (!result)
-		return 1;
-
-	while (result) {
-		struct commit *commit = result->item;
-		result = result->next;
-		if (commit->object.flags & UNINTERESTING)
-			continue;
-		printf("%s\n", sha1_to_hex(commit->object.sha1));
-		if (!show_all)
-			return 0;
-		commit->object.flags |= UNINTERESTING;
-	}
-	return 0;
-}
-
-static const char merge_base_usage[] =
-"git-merge-base [--all] <commit-id> <commit-id>";
-
-int main(int argc, char **argv)
-{
-	struct commit *rev1, *rev2;
-	unsigned char rev1key[20], rev2key[20];
-
-	while (1 < argc && argv[1][0] == '-') {
-		char *arg = argv[1];
-		if (!strcmp(arg, "-a") || !strcmp(arg, "--all"))
-			show_all = 1;
-		else
-			usage(merge_base_usage);
-		argc--; argv++;
-	}
-	if (argc != 3 ||
-	    get_sha1(argv[1], rev1key) ||
-	    get_sha1(argv[2], rev2key))
-		usage(merge_base_usage);
-	rev1 = lookup_commit_reference(rev1key);
-	rev2 = lookup_commit_reference(rev2key);
-	if (!rev1 || !rev2)
-		return 1;
-	return merge_base(rev1, rev2);
-}
diff --git a/t/t4100/t-apply-1.patch b/t/t4100/t-apply-1.patch
--- a/t/t4100/t-apply-1.patch
+++ b/t/t4100/t-apply-1.patch
@@ -92,7 +92,7 @@ diff --git a/Makefile b/Makefile
 +++ b/Makefile
 @@ -30,7 +30,7 @@ PROG=   git-update-cache git-diff-files 
  	git-checkout-cache git-diff-tree git-rev-tree git-ls-files \
- 	git-check-files git-ls-tree git-merge-base git-merge-cache \
+ 	git-check-files git-ls-tree git-find-merge-base git-merge-cache \
  	git-unpack-file git-export git-diff-cache git-convert-cache \
 -	git-http-pull git-rpush git-rpull git-rev-list git-mktag \
 +	git-http-pull git-ssh-push git-ssh-pull git-rev-list git-mktag \
diff --git a/t/t4100/t-apply-5.patch b/t/t4100/t-apply-5.patch
--- a/t/t4100/t-apply-5.patch
+++ b/t/t4100/t-apply-5.patch
@@ -202,7 +202,7 @@ diff a/Makefile b/Makefile
 +++ b/Makefile
 @@ -30,7 +30,7 @@ PROG=   git-update-cache git-diff-files 
  	git-checkout-cache git-diff-tree git-rev-tree git-ls-files \
- 	git-check-files git-ls-tree git-merge-base git-merge-cache \
+ 	git-check-files git-ls-tree git-find-merge-base git-merge-cache \
  	git-unpack-file git-export git-diff-cache git-convert-cache \
 -	git-http-pull git-rpush git-rpull git-rev-list git-mktag \
 +	git-http-pull git-ssh-push git-ssh-pull git-rev-list git-mktag \
diff --git a/templates/hooks--update b/templates/hooks--update
--- a/templates/hooks--update
+++ b/templates/hooks--update
@@ -15,7 +15,7 @@ then
 	echo "Created a new ref, with the following commits:"
 	git-rev-list --pretty "$3"
 else
-	$base=$(git-merge-base "$2" "$3")
+	$base=$(git-find-merge-base "$2" "$3")
 	case "$base" in
 	"$2")
 		echo "New commits:"
