From: Vitaly Mayatskikh <v.mayatskih@gmail.com>
Subject: [PATCH] git-send-email: parse all messages in mbox
Date: Mon, 11 May 2009 15:46:51 +0200
Message-ID: <873abbeoqc.wl%vmayatsk@redhat.com>
Mime-Version: 1.0 (generated by SEMI 1.14.6 - "Maruoka")
Content-Type: text/plain; charset=US-ASCII
To: git@vger.kernel.org
X-From: git-owner@vger.kernel.org Mon May 11 15:47:57 2009
Return-path: <git-owner@vger.kernel.org>
Envelope-to: gcvg-git-2@gmane.org
Received: from vger.kernel.org ([209.132.176.167])
	by lo.gmane.org with esmtp (Exim 4.50)
	id 1M3Vr9-00028c-AY
	for gcvg-git-2@gmane.org; Mon, 11 May 2009 15:47:48 +0200
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751772AbZEKNq7 (ORCPT <rfc822;gcvg-git-2@m.gmane.org>);
	Mon, 11 May 2009 09:46:59 -0400
Received: (majordomo@vger.kernel.org) by vger.kernel.org id S1751575AbZEKNq7
	(ORCPT <rfc822;git-outgoing>); Mon, 11 May 2009 09:46:59 -0400
Received: from mail-ew0-f176.google.com ([209.85.219.176]:58379 "EHLO
	mail-ew0-f176.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751572AbZEKNq5 (ORCPT <rfc822;git@vger.kernel.org>);
	Mon, 11 May 2009 09:46:57 -0400
Received: by ewy24 with SMTP id 24so3428184ewy.37
        for <git@vger.kernel.org>; Mon, 11 May 2009 06:46:53 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=gamma;
        h=domainkey-signature:received:received:date:message-id:from:to
         :subject:user-agent:mime-version:content-type;
        bh=H7DciYXPm8HAj8PHWGYVS/8Yg7bviXnVl9tGjE2qnWc=;
        b=pOrPVCkMpB03AZx90kNy2S4D+lSrF/KIQP1y0yntFXyFYbSsMLMIyv6Z0CSF2bnz7H
         HO5IbOZOxZFW8QYaktjb1n5WlDmcCTTE6VOgvJGK/C3b3oTSHpvjCAcMJhEgOb7T9gvX
         Vc5w/eWxnZ/tQgQgZBDr/Tzmnp7C9wCtqZExc=
DomainKey-Signature: a=rsa-sha1; c=nofws;
        d=gmail.com; s=gamma;
        h=date:message-id:from:to:subject:user-agent:mime-version
         :content-type;
        b=ErPIsKMtYABB+cz4/6Q3z6bzilUnyxlXio1V3DmX5cKSaJlSBzT+ypsb4V8ob4d/5P
         F3tfIMDfPY9HaYh1VriWSBEblqb1NFgEcgTWirr+Qj0BinkJX/ea4+j5sk8IE3anSXM0
         TTJICxe0K3xEqadoEhdH5o0HpBQZUHXTYPVD4=
Received: by 10.210.87.11 with SMTP id k11mr3402880ebb.91.1242049613101;
        Mon, 11 May 2009 06:46:53 -0700 (PDT)
Received: from gravicappa.englab.brq.redhat.com (nat-pool-brq.redhat.com [62.40.79.66])
        by mx.google.com with ESMTPS id 7sm7784073eyb.45.2009.05.11.06.46.52
        (version=TLSv1/SSLv3 cipher=RC4-MD5);
        Mon, 11 May 2009 06:46:52 -0700 (PDT)
User-Agent: Wanderlust/2.15.6 (Almost Unreal) Emacs/22.3 Mule/5.0 (SAKAKI)
Sender: git-owner@vger.kernel.org
Precedence: bulk
List-ID: <git.vger.kernel.org>
X-Mailing-List: git@vger.kernel.org
Archived-At: <http://permalink.gmane.org/gmane.comp.version-control.git/118797>

Currently git-send-email sends all mbox in one email. This seems to be wrong,
because mbox can contain several messages. For example,
`git format-patch --stdout' forms mbox file with all patches in it.

This patch allows git send-email to send several messages from one mbox
separately.

Signed-off-by: Vitaly Mayatskikh <v.mayatskih@gmail.com>
---
 git-send-email.perl |  278 ++++++++++++++++++++++++++-------------------------
 1 files changed, 141 insertions(+), 137 deletions(-)

diff --git a/git-send-email.perl b/git-send-email.perl
index cccbf45..614fcbd 100755
--- a/git-send-email.perl
+++ b/git-send-email.perl
@@ -984,168 +984,172 @@ $message_num = 0;
 foreach my $t (@files) {
 	open(F,"<",$t) or die "can't open file $t";
 
-	my $author = undef;
-	my $author_encoding;
-	my $has_content_type;
-	my $body_encoding;
-	@cc = ();
-	@xh = ();
-	my $input_format = undef;
-	my @header = ();
-	$message = "";
-	$message_num++;
-	# First unfold multiline header fields
-	while(<F>) {
-		last if /^\s*$/;
-		if (/^\s+\S/ and @header) {
-			chomp($header[$#header]);
-			s/^\s+/ /;
-			$header[$#header] .= $_;
-	    } else {
-			push(@header, $_);
-		}
-	}
-	# Now parse the header
-	foreach(@header) {
-		if (/^From /) {
-			$input_format = 'mbox';
-			next;
-		}
-		chomp;
-		if (!defined $input_format && /^[-A-Za-z]+:\s/) {
-			$input_format = 'mbox';
+	while (1) {
+		my $author = undef;
+		my $author_encoding;
+		my $has_content_type;
+		my $body_encoding;
+		@cc = ();
+		@xh = ();
+		my $input_format = undef;
+		my @header = ();
+		$message = "";
+		$message_num++;
+		# First unfold multiline header fields
+		while(<F>) {
+			last if /^\s*$/;
+			if (/^\s+\S/ and @header) {
+				chomp($header[$#header]);
+				s/^\s+/ /;
+				$header[$#header] .= $_;
+			} else {
+				push(@header, $_);
+			}
 		}
-
-		if (defined $input_format && $input_format eq 'mbox') {
-			if (/^Subject:\s+(.*)$/) {
-				$subject = $1;
+		# Now parse the header
+		foreach(@header) {
+			if (/^From /) {
+				$input_format = 'mbox';
+				next;
 			}
-			elsif (/^From:\s+(.*)$/) {
-				($author, $author_encoding) = unquote_rfc2047($1);
-				next if $suppress_cc{'author'};
-				next if $suppress_cc{'self'} and $author eq $sender;
-				printf("(mbox) Adding cc: %s from line '%s'\n",
-					$1, $_) unless $quiet;
-				push @cc, $1;
+			chomp;
+			if (!defined $input_format && /^[-A-Za-z]+:\s/) {
+				$input_format = 'mbox';
 			}
-			elsif (/^Cc:\s+(.*)$/) {
-				foreach my $addr (parse_address_line($1)) {
-					if (unquote_rfc2047($addr) eq $sender) {
-						next if ($suppress_cc{'self'});
-					} else {
-						next if ($suppress_cc{'cc'});
-					}
+
+			if (defined $input_format && $input_format eq 'mbox') {
+				if (/^Subject:\s+(.*)$/) {
+					$subject = $1;
+				}
+				elsif (/^From:\s+(.*)$/) {
+					($author, $author_encoding) = unquote_rfc2047($1);
+					next if $suppress_cc{'author'};
+					next if $suppress_cc{'self'} and $author eq $sender;
 					printf("(mbox) Adding cc: %s from line '%s'\n",
-						$addr, $_) unless $quiet;
-					push @cc, $addr;
+					       $1, $_) unless $quiet;
+					push @cc, $1;
 				}
-			}
-			elsif (/^Content-type:/i) {
-				$has_content_type = 1;
-				if (/charset="?([^ "]+)/) {
-					$body_encoding = $1;
+				elsif (/^Cc:\s+(.*)$/) {
+					foreach my $addr (parse_address_line($1)) {
+						if (unquote_rfc2047($addr) eq $sender) {
+							next if ($suppress_cc{'self'});
+						} else {
+							next if ($suppress_cc{'cc'});
+						}
+						printf("(mbox) Adding cc: %s from line '%s'\n",
+						       $addr, $_) unless $quiet;
+						push @cc, $addr;
+					}
+				}
+				elsif (/^Content-type:/i) {
+					$has_content_type = 1;
+					if (/charset="?([^ "]+)/) {
+						$body_encoding = $1;
+					}
+					push @xh, $_;
+				}
+				elsif (/^Message-Id: (.*)/i) {
+					$message_id = $1;
+				}
+				elsif (!/^Date:\s/ && /^[-A-Za-z]+:\s+\S/) {
+					push @xh, $_;
 				}
-				push @xh, $_;
-			}
-			elsif (/^Message-Id: (.*)/i) {
-				$message_id = $1;
-			}
-			elsif (!/^Date:\s/ && /^[-A-Za-z]+:\s+\S/) {
-				push @xh, $_;
-			}
 
-		} else {
-			# In the traditional
-			# "send lots of email" format,
-			# line 1 = cc
-			# line 2 = subject
-			# So let's support that, too.
-			$input_format = 'lots';
-			if (@cc == 0 && !$suppress_cc{'cc'}) {
-				printf("(non-mbox) Adding cc: %s from line '%s'\n",
-					$_, $_) unless $quiet;
-				push @cc, $_;
-			} elsif (!defined $subject) {
-				$subject = $_;
+			} else {
+				# In the traditional
+				# "send lots of email" format,
+				# line 1 = cc
+				# line 2 = subject
+				# So let's support that, too.
+				$input_format = 'lots';
+				if (@cc == 0 && !$suppress_cc{'cc'}) {
+					printf("(non-mbox) Adding cc: %s from line '%s'\n",
+					       $_, $_) unless $quiet;
+					push @cc, $_;
+				} elsif (!defined $subject) {
+					$subject = $_;
+				}
 			}
 		}
-	}
-	# Now parse the message body
-	while(<F>) {
-		$message .=  $_;
-		if (/^(Signed-off-by|Cc): (.*)$/i) {
-			chomp;
-			my ($what, $c) = ($1, $2);
-			chomp $c;
-			if ($c eq $sender) {
-				next if ($suppress_cc{'self'});
-			} else {
-				next if $suppress_cc{'sob'} and $what =~ /Signed-off-by/i;
-				next if $suppress_cc{'bodycc'} and $what =~ /Cc/i;
+		# Now parse the message body
+		while(<F>) {
+			last if /^From /; # Next message in file
+			$message .=  $_;
+			if (/^(Signed-off-by|Cc): (.*)$/i) {
+				chomp;
+				my ($what, $c) = ($1, $2);
+				chomp $c;
+				if ($c eq $sender) {
+					next if ($suppress_cc{'self'});
+				} else {
+					next if $suppress_cc{'sob'} and $what =~ /Signed-off-by/i;
+					next if $suppress_cc{'bodycc'} and $what =~ /Cc/i;
+				}
+				push @cc, $c;
+				printf("(body) Adding cc: %s from line '%s'\n",
+				       $c, $_) unless $quiet;
 			}
-			push @cc, $c;
-			printf("(body) Adding cc: %s from line '%s'\n",
-				$c, $_) unless $quiet;
 		}
-	}
-	close F;
 
-	if (defined $cc_cmd && !$suppress_cc{'cccmd'}) {
-		open(F, "$cc_cmd $t |")
-			or die "(cc-cmd) Could not execute '$cc_cmd'";
-		while(<F>) {
-			my $c = $_;
-			$c =~ s/^\s*//g;
-			$c =~ s/\n$//g;
-			next if ($c eq $sender and $suppress_from);
-			push @cc, $c;
-			printf("(cc-cmd) Adding cc: %s from: '%s'\n",
-				$c, $cc_cmd) unless $quiet;
+		if (defined $cc_cmd && !$suppress_cc{'cccmd'}) {
+			open(CC_CMD, "$cc_cmd $t |")
+			    or die "(cc-cmd) Could not execute '$cc_cmd'";
+			while(<CC_CMD>) {
+				my $c = $_;
+				$c =~ s/^\s*//g;
+				$c =~ s/\n$//g;
+				next if ($c eq $sender and $suppress_from);
+				push @cc, $c;
+				printf("(cc-cmd) Adding cc: %s from: '%s'\n",
+				       $c, $cc_cmd) unless $quiet;
+			}
+			close CC_CMD
+			    or die "(cc-cmd) failed to close pipe to '$cc_cmd'";
 		}
-		close F
-			or die "(cc-cmd) failed to close pipe to '$cc_cmd'";
-	}
 
-	if (defined $author and $author ne $sender) {
-		$message = "From: $author\n\n$message";
-		if (defined $author_encoding) {
-			if ($has_content_type) {
-				if ($body_encoding eq $author_encoding) {
-					# ok, we already have the right encoding
+		if (defined $author and $author ne $sender) {
+			$message = "From: $author\n\n$message";
+			if (defined $author_encoding) {
+				if ($has_content_type) {
+					if ($body_encoding eq $author_encoding) {
+						# ok, we already have the right encoding
+					}
+					else {
+						# uh oh, we should re-encode
+					}
 				}
 				else {
-					# uh oh, we should re-encode
+					push @xh,
+					'MIME-Version: 1.0',
+					"Content-Type: text/plain; charset=$author_encoding",
+					'Content-Transfer-Encoding: 8bit';
 				}
 			}
-			else {
-				push @xh,
-				  'MIME-Version: 1.0',
-				  "Content-Type: text/plain; charset=$author_encoding",
-				  'Content-Transfer-Encoding: 8bit';
-			}
 		}
-	}
 
-	$needs_confirm = (
-		$confirm eq "always" or
-		($confirm =~ /^(?:auto|cc)$/ && @cc) or
-		($confirm =~ /^(?:auto|compose)$/ && $compose && $message_num == 1));
-	$needs_confirm = "inform" if ($needs_confirm && $confirm_unconfigured && @cc);
+		$needs_confirm = (
+			$confirm eq "always" or
+			($confirm =~ /^(?:auto|cc)$/ && @cc) or
+			($confirm =~ /^(?:auto|compose)$/ && $compose && $message_num == 1));
+		$needs_confirm = "inform" if ($needs_confirm && $confirm_unconfigured && @cc);
 
-	@cc = (@initial_cc, @cc);
+		@cc = (@initial_cc, @cc);
 
-	send_message();
+		send_message();
 
-	# set up for the next message
-	if ($chain_reply_to || !defined $reply_to || length($reply_to) == 0) {
-		$reply_to = $message_id;
-		if (length $references > 0) {
-			$references .= "\n $message_id";
-		} else {
-			$references = "$message_id";
+		# set up for the next message
+		if ($chain_reply_to || !defined $reply_to || length($reply_to) == 0) {
+			$reply_to = $message_id;
+			if (length $references > 0) {
+				$references .= "\n $message_id";
+			} else {
+				$references = "$message_id";
+			}
 		}
+		$message_id = undef;
+		last unless (<F>);
 	}
-	$message_id = undef;
+	close F;
 }
 
 cleanup_compose_files();

-- 
wbr, Vitaly
