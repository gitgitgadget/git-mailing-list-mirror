Return-Path: <git-owner@vger.kernel.org>
X-Spam-Checker-Version: SpamAssassin 3.4.1 (2015-04-28) on dcvr.yhbt.net
X-Spam-Level: 
X-Spam-ASN: AS31976 209.132.180.0/23
X-Spam-Status: No, score=-3.5 required=3.0 tests=AWL,BAYES_00,DKIM_SIGNED,
	DKIM_VALID,DKIM_VALID_AU,FREEMAIL_FORGED_FROMDOMAIN,FREEMAIL_FROM,
	HEADER_FROM_DIFFERENT_DOMAINS,MAILING_LIST_MULTI,RCVD_IN_DNSWL_HI
	shortcircuit=no autolearn=ham autolearn_force=no version=3.4.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by dcvr.yhbt.net (Postfix) with ESMTP id C4F101F403
	for <e@80x24.org>; Tue, 19 Jun 2018 11:41:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S965152AbeFSLlu (ORCPT <rfc822;e@80x24.org>);
        Tue, 19 Jun 2018 07:41:50 -0400
Received: from mail-qk0-f177.google.com ([209.85.220.177]:37554 "EHLO
        mail-qk0-f177.google.com" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S965149AbeFSLlr (ORCPT <rfc822;git@vger.kernel.org>);
        Tue, 19 Jun 2018 07:41:47 -0400
Received: by mail-qk0-f177.google.com with SMTP id j12-v6so11137927qkk.4
        for <git@vger.kernel.org>; Tue, 19 Jun 2018 04:41:47 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=gmail.com; s=20161025;
        h=from:to:cc:subject:date:message-id:in-reply-to:references;
        bh=/BYFRBKd0CmmJ7BHka/mCkbSkWtUbu6rsbj2QdTVvY4=;
        b=pCuUTLMkioEz5StGzUPmbGn4tyRhc4IcREMiXajEA5N4dALWrlaHUYJSoPKnN2+JfK
         1wKIoN4z+1iuylbP9DNGtacYN4YggfpOWFAmrz+Toc2igYVhNYwVQTwq2szolE8d/i0D
         +0yru60r0tuJHLSLUUzAF39SN5fKALi5co4Q1Nztwh5GR29C1cg8xfmDMuJk/DjpYw5x
         0PSz12iubN3Sug3fAn7lsJWzmXHnPPNEe19p5NgeQIdReie7bI5IAynBTb8SbbF1l54V
         WsAgQRM2GVB77minscgVs9ii8XrRwS9FwaMWh4a2CBLLVHIz5al3SzTCJJskRdi8I1I7
         3SQA==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20161025;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
         :references;
        bh=/BYFRBKd0CmmJ7BHka/mCkbSkWtUbu6rsbj2QdTVvY4=;
        b=LS38y8ch/INppv+zzyZebCeL06eNk+S1tBPkOwPLV5cPN1HAl/WN6dpPq6USLFRUxy
         rXQHPREJ6mvZpQtxZajTq994zBYS+e4Wvd89ZkYZ5WqTiT2lzsl5BtyZ4AhhR0xFBXpq
         G/uVMazp9FTqGq+2FBkOBweMlKdL8omoHwO+Reu0jvfEKAlOl16yyV2i4UKwOMUkBGfJ
         2NhJpPxj6FAurQ9a1+LRfTs3CgqkS4vM8U4VsJH35BDgjtW/Q6DC75lB0I/z+SyGUuVF
         f8eHQ6IqkTaDhQgIKvSk4MHTh3VuuZo2uUTQxMcb9oT5iwHybzT598vjxoS/fDpcU8PT
         ayig==
X-Gm-Message-State: APt69E1j+9Cg0Kr40Y7OokjKTVTKD51fKSThyAA7tfMElWfQggnTd+zg
        OSDy6nxndR69vdKPP/I5pP/H3ZyU
X-Google-Smtp-Source: ADUXVKIgGlseL/5Z7Q2nf6jyRfrJduKJGPoBzwMB+NZhOfarQOR9/Qe2BR2H0+zmy3LP9iR/YpwvAQ==
X-Received: by 2002:a37:2801:: with SMTP id o1-v6mr13227957qkh.319.1529408505624;
        Tue, 19 Jun 2018 04:41:45 -0700 (PDT)
Received: from stolee-linux-2.corp.microsoft.com ([2001:4898:8010:0:eb4a:5dff:fe0f:730f])
        by smtp.gmail.com with ESMTPSA id m6-v6sm19426408qkm.12.2018.06.19.04.41.44
        (version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
        Tue, 19 Jun 2018 04:41:44 -0700 (PDT)
From:   Derrick Stolee <stolee@gmail.com>
X-Google-Original-From: Derrick Stolee <dstolee@microsoft.com>
To:     git@vger.kernel.org
Cc:     pclouds@gmail.com
Subject: Re: [PATCH 01/15] contrib: add cocci script to replace index compat macros
Date:   Tue, 19 Jun 2018 07:41:43 -0400
Message-Id: <20180619114143.206568-1-dstolee@microsoft.com>
X-Mailer: git-send-email 2.18.0.rc1
In-Reply-To: <a7e0bcd5-5bef-097e-f032-d152d51515aa@gmail.com>
References: <a7e0bcd5-5bef-097e-f032-d152d51515aa@gmail.com>
Sender: git-owner@vger.kernel.org
Precedence: bulk
List-ID: <git.vger.kernel.org>
X-Mailing-List: git@vger.kernel.org

Duy,

Here is the patch that was generated by `make coccicheck`.

Thanks,
-Stolee

-->8--

--- builtin/add.c
+++ /tmp/cocci-output-206193-4c91ec-add.c
@@ -38,13 +38,13 @@ static void chmod_pathspec(struct pathsp
 {
 	int i;
 
-	for (i = 0; i < active_nr; i++) {
-		struct cache_entry *ce = active_cache[i];
+	for (i = 0; i < the_index.cache_nr; i++) {
+		struct cache_entry *ce = the_index.cache[i];
 
 		if (pathspec && !ce_path_match(&the_index, ce, pathspec, NULL))
 			continue;
 
-		if (chmod_cache_entry(ce, flip) < 0)
+		if (chmod_index_entry(&the_index, ce, flip) < 0)
 			fprintf(stderr, "cannot chmod %cx '%s'\n", flip, ce->name);
 	}
 }
@@ -129,8 +129,8 @@ static int renormalize_tracked_files(con
 {
 	int i, retval = 0;
 
-	for (i = 0; i < active_nr; i++) {
-		struct cache_entry *ce = active_cache[i];
+	for (i = 0; i < the_index.cache_nr; i++) {
+		struct cache_entry *ce = the_index.cache[i];
 
 		if (ce_stage(ce))
 			continue; /* do not touch unmerged paths */
@@ -138,7 +138,8 @@ static int renormalize_tracked_files(con
 			continue; /* do not touch non blobs */
 		if (pathspec && !ce_path_match(&the_index, ce, pathspec, NULL))
 			continue;
-		retval |= add_file_to_cache(ce->name, flags | HASH_RENORMALIZE);
+		retval |= add_file_to_index(&the_index, ce->name,
+					    flags | HASH_RENORMALIZE);
 	}
 
 	return retval;
@@ -230,7 +231,7 @@ static int edit_patch(int argc, const ch
 
 	git_config(git_diff_basic_config, NULL); /* no "diff" UI options */
 
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("Could not read the index"));
 
 	init_revisions(&rev, the_repository, prefix);
@@ -445,7 +446,7 @@ int cmd_add(int argc, const char **argv,
 		return 0;
 	}
 
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 
 	die_in_unpopulated_submodule(&the_index, prefix);
--- builtin/am.c
+++ /tmp/cocci-output-206198-3fcbd5-am.c
@@ -1144,7 +1144,7 @@ static void refresh_and_write_cache(void
 	struct lock_file lock_file = LOCK_INIT;
 
 	hold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);
-	refresh_cache(REFRESH_QUIET);
+	refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 	if (write_locked_index(&the_index, &lock_file, COMMIT_LOCK))
 		die(_("unable to write index file"));
 }
@@ -1505,8 +1505,8 @@ static int run_apply(const struct am_sta
 
 	if (index_file) {
 		/* Reload index as apply_all_patches() will have modified it. */
-		discard_cache();
-		read_cache_from(index_file);
+		discard_index(&the_index);
+		read_index_from(&the_index, index_file, get_git_dir());
 	}
 
 	return 0;
@@ -1548,8 +1548,8 @@ static int fall_back_threeway(const stru
 	if (build_fake_ancestor(state, index_path))
 		return error("could not build fake ancestor");
 
-	discard_cache();
-	read_cache_from(index_path);
+	discard_index(&the_index);
+	read_index_from(&the_index, index_path, get_git_dir());
 
 	if (write_index_as_tree(&orig_tree, &the_index, index_path, 0, NULL))
 		return error(_("Repository lacks necessary blobs to fall back on 3-way merge."));
@@ -1581,8 +1581,8 @@ static int fall_back_threeway(const stru
 
 	say(state, stdout, _("Falling back to patching base and 3-way merge..."));
 
-	discard_cache();
-	read_cache();
+	discard_index(&the_index);
+	read_index(&the_index);
 
 	/*
 	 * This is not so wrong. Depending on which base we picked, orig_tree
@@ -1886,7 +1886,7 @@ static void am_resolve(struct am_state *
 		die_user_resolve(state);
 	}
 
-	if (unmerged_cache()) {
+	if (unmerged_index(&the_index)) {
 		printf_ln(_("You still have unmerged paths in your index.\n"
 			"You should 'git add' each file with resolved conflicts to mark them as such.\n"
 			"You might run `git rm` on a file to accept \"deleted by them\" for it."));
@@ -1925,7 +1925,7 @@ static int fast_forward_to(struct tree *
 
 	hold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);
 
-	refresh_cache(REFRESH_QUIET);
+	refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 
 	memset(&opts, 0, sizeof(opts));
 	opts.head_idx = 1;
@@ -2000,7 +2000,7 @@ static int clean_index(const struct obje
 	if (!remote_tree)
 		return error(_("Could not parse object '%s'."), oid_to_hex(remote));
 
-	read_cache_unmerged();
+	read_index_unmerged(&the_index);
 
 	if (fast_forward_to(head_tree, head_tree, 1))
 		return -1;
--- builtin/check-attr.c
+++ /tmp/cocci-output-206211-cd89a4-check-attr.c
@@ -116,7 +116,7 @@ int cmd_check_attr(int argc, const char
 	argc = parse_options(argc, argv, prefix, check_attr_options,
 			     check_attr_usage, PARSE_OPT_KEEP_DASHDASH);
 
-	if (read_cache() < 0) {
+	if (read_index(&the_index) < 0) {
 		die("invalid cache");
 	}
 
--- builtin/check-ignore.c
+++ /tmp/cocci-output-206216-286c84-check-ignore.c
@@ -174,7 +174,7 @@ int cmd_check_ignore(int argc, const cha
 		die(_("--non-matching is only valid with --verbose"));
 
 	/* read_cache() is only necessary so we can watch out for submodules. */
-	if (!no_index && read_cache() < 0)
+	if (!no_index && read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 
 	memset(&dir, 0, sizeof(dir));
--- builtin/checkout-index.c
+++ /tmp/cocci-output-206223-d5d099-checkout-index.c
@@ -48,7 +48,7 @@ static void write_tempfile_record(const
 static int checkout_file(const char *name, const char *prefix)
 {
 	int namelen = strlen(name);
-	int pos = cache_name_pos(name, namelen);
+	int pos = index_name_pos(&the_index, name, namelen);
 	int has_same_name = 0;
 	int did_checkout = 0;
 	int errs = 0;
@@ -56,8 +56,8 @@ static int checkout_file(const char *nam
 	if (pos < 0)
 		pos = -pos - 1;
 
-	while (pos < active_nr) {
-		struct cache_entry *ce = active_cache[pos];
+	while (pos < the_index.cache_nr) {
+		struct cache_entry *ce = the_index.cache[pos];
 		if (ce_namelen(ce) != namelen ||
 		    memcmp(ce->name, name, namelen))
 			break;
@@ -97,8 +97,8 @@ static void checkout_all(const char *pre
 	int i, errs = 0;
 	struct cache_entry *last_ce = NULL;
 
-	for (i = 0; i < active_nr ; i++) {
-		struct cache_entry *ce = active_cache[i];
+	for (i = 0; i < the_index.cache_nr ; i++) {
+		struct cache_entry *ce = the_index.cache[i];
 		if (ce_stage(ce) != checkout_stage
 		    && (CHECKOUT_ALL != checkout_stage || !ce_stage(ce)))
 			continue;
@@ -185,7 +185,7 @@ int cmd_checkout_index(int argc, const c
 	git_config(git_default_config, NULL);
 	prefix_length = prefix ? strlen(prefix) : 0;
 
-	if (read_cache() < 0) {
+	if (read_index(&the_index) < 0) {
 		die("invalid cache");
 	}
 
--- builtin/checkout.c
+++ /tmp/cocci-output-206228-3a013e-checkout.c
@@ -91,9 +91,9 @@ static int update_some(const struct obje
 	 * entry in place. Whether it is UPTODATE or not, checkout_entry will
 	 * do the right thing.
 	 */
-	pos = cache_name_pos(ce->name, ce->ce_namelen);
+	pos = index_name_pos(&the_index, ce->name, ce->ce_namelen);
 	if (pos >= 0) {
-		struct cache_entry *old = active_cache[pos];
+		struct cache_entry *old = the_index.cache[pos];
 		if (ce->ce_mode == old->ce_mode &&
 		    !oidcmp(&ce->oid, &old->oid)) {
 			old->ce_flags |= CE_UPDATE;
@@ -102,7 +102,8 @@ static int update_some(const struct obje
 		}
 	}
 
-	add_cache_entry(ce, ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);
+	add_index_entry(&the_index, ce,
+			ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);
 	return 0;
 }
 
@@ -119,17 +120,17 @@ static int read_tree_some(struct tree *t
 
 static int skip_same_name(const struct cache_entry *ce, int pos)
 {
-	while (++pos < active_nr &&
-	       !strcmp(active_cache[pos]->name, ce->name))
+	while (++pos < the_index.cache_nr &&
+	       !strcmp(the_index.cache[pos]->name, ce->name))
 		; /* skip */
 	return pos;
 }
 
 static int check_stage(int stage, const struct cache_entry *ce, int pos)
 {
-	while (pos < active_nr &&
-	       !strcmp(active_cache[pos]->name, ce->name)) {
-		if (ce_stage(active_cache[pos]) == stage)
+	while (pos < the_index.cache_nr &&
+	       !strcmp(the_index.cache[pos]->name, ce->name)) {
+		if (ce_stage(the_index.cache[pos]) == stage)
 			return 0;
 		pos++;
 	}
@@ -144,8 +145,8 @@ static int check_stages(unsigned stages,
 	unsigned seen = 0;
 	const char *name = ce->name;
 
-	while (pos < active_nr) {
-		ce = active_cache[pos];
+	while (pos < the_index.cache_nr) {
+		ce = the_index.cache[pos];
 		if (strcmp(name, ce->name))
 			break;
 		seen |= (1 << ce_stage(ce));
@@ -160,10 +161,11 @@ static int check_stages(unsigned stages,
 static int checkout_stage(int stage, const struct cache_entry *ce, int pos,
 			  const struct checkout *state)
 {
-	while (pos < active_nr &&
-	       !strcmp(active_cache[pos]->name, ce->name)) {
-		if (ce_stage(active_cache[pos]) == stage)
-			return checkout_entry(active_cache[pos], state, NULL);
+	while (pos < the_index.cache_nr &&
+	       !strcmp(the_index.cache[pos]->name, ce->name)) {
+		if (ce_stage(the_index.cache[pos]) == stage)
+			return checkout_entry(the_index.cache[pos], state,
+				              NULL);
 		pos++;
 	}
 	if (stage == 2)
@@ -174,7 +176,7 @@ static int checkout_stage(int stage, con
 
 static int checkout_merged(int pos, const struct checkout *state)
 {
-	struct cache_entry *ce = active_cache[pos];
+	struct cache_entry *ce = the_index.cache[pos];
 	const char *path = ce->name;
 	mmfile_t ancestor, ours, theirs;
 	int status;
@@ -184,7 +186,7 @@ static int checkout_merged(int pos, cons
 	unsigned mode = 0;
 
 	memset(threeway, 0, sizeof(threeway));
-	while (pos < active_nr) {
+	while (pos < the_index.cache_nr) {
 		int stage;
 		stage = ce_stage(ce);
 		if (!stage || strcmp(path, ce->name))
@@ -193,7 +195,7 @@ static int checkout_merged(int pos, cons
 		if (stage == 2)
 			mode = create_ce_mode(ce->ce_mode);
 		pos++;
-		ce = active_cache[pos];
+		ce = the_index.cache[pos];
 	}
 	if (is_null_oid(&threeway[1]) || is_null_oid(&threeway[2]))
 		return error(_("path '%s' does not have necessary versions"), path);
@@ -278,7 +280,7 @@ static int checkout_paths(const struct c
 					   &opts->pathspec);
 
 	hold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);
-	if (read_cache_preload(&opts->pathspec) < 0)
+	if (read_index_preload(&the_index, &opts->pathspec) < 0)
 		return error(_("index file corrupt"));
 
 	if (opts->source_tree)
@@ -290,8 +292,8 @@ static int checkout_paths(const struct c
 	 * Make sure all pathspecs participated in locating the paths
 	 * to be checked out.
 	 */
-	for (pos = 0; pos < active_nr; pos++) {
-		struct cache_entry *ce = active_cache[pos];
+	for (pos = 0; pos < the_index.cache_nr; pos++) {
+		struct cache_entry *ce = the_index.cache[pos];
 		ce->ce_flags &= ~CE_MATCHED;
 		if (!opts->ignore_skipworktree && ce_skip_worktree(ce))
 			continue;
@@ -333,8 +335,8 @@ static int checkout_paths(const struct c
 		unmerge_marked_index(&the_index);
 
 	/* Any unmerged paths? */
-	for (pos = 0; pos < active_nr; pos++) {
-		const struct cache_entry *ce = active_cache[pos];
+	for (pos = 0; pos < the_index.cache_nr; pos++) {
+		const struct cache_entry *ce = the_index.cache[pos];
 		if (ce->ce_flags & CE_MATCHED) {
 			if (!ce_stage(ce))
 				continue;
@@ -360,8 +362,8 @@ static int checkout_paths(const struct c
 	state.istate = &the_index;
 
 	enable_delayed_checkout(&state);
-	for (pos = 0; pos < active_nr; pos++) {
-		struct cache_entry *ce = active_cache[pos];
+	for (pos = 0; pos < the_index.cache_nr; pos++) {
+		struct cache_entry *ce = the_index.cache[pos];
 		if (ce->ce_flags & CE_MATCHED) {
 			if (!ce_stage(ce)) {
 				errs |= checkout_entry(ce, &state, NULL);
@@ -481,10 +483,10 @@ static int merge_working_tree(const stru
 	struct lock_file lock_file = LOCK_INIT;
 
 	hold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);
-	if (read_cache_preload(NULL) < 0)
+	if (read_index_preload(&the_index, NULL) < 0)
 		return error(_("index file corrupt"));
 
-	resolve_undo_clear();
+	resolve_undo_clear_index(&the_index);
 	if (opts->force) {
 		ret = reset_tree(get_commit_tree(new_branch_info->commit),
 				 opts, 1, writeout_error);
@@ -502,15 +504,15 @@ static int merge_working_tree(const stru
 
 		setup_unpack_trees_porcelain(&topts, "checkout");
 
-		refresh_cache(REFRESH_QUIET);
+		refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 
-		if (unmerged_cache()) {
+		if (unmerged_index(&the_index)) {
 			error(_("you need to resolve your current index first"));
 			return 1;
 		}
 
 		/* 2-way merge to the new branch */
-		topts.initial_checkout = is_cache_unborn();
+		topts.initial_checkout = is_index_unborn(&the_index);
 		topts.update = 1;
 		topts.merge = 1;
 		topts.gently = opts->merge && old_branch_info->commit;
@@ -598,10 +600,10 @@ static int merge_working_tree(const stru
 		}
 	}
 
-	if (!active_cache_tree)
-		active_cache_tree = cache_tree();
+	if (!the_index.cache_tree)
+		the_index.cache_tree = cache_tree();
 
-	if (!cache_tree_fully_valid(active_cache_tree))
+	if (!cache_tree_fully_valid(the_index.cache_tree))
 		cache_tree_update(&the_index, WRITE_TREE_SILENT | WRITE_TREE_REPAIR);
 
 	if (write_locked_index(&the_index, &lock_file, COMMIT_LOCK))
--- builtin/clean.c
+++ /tmp/cocci-output-206233-6cec8a-clean.c
@@ -955,7 +955,7 @@ int cmd_clean(int argc, const char **arg
 	if (remove_directories)
 		dir.flags |= DIR_SHOW_IGNORED_TOO | DIR_KEEP_UNTRACKED_CONTENTS;
 
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 
 	if (!ignored)
@@ -978,7 +978,7 @@ int cmd_clean(int argc, const char **arg
 		struct stat st;
 		const char *rel;
 
-		if (!cache_name_is_other(ent->name, ent->len))
+		if (!index_name_is_other(&the_index, ent->name, ent->len))
 			continue;
 
 		if (pathspec.nr)
--- builtin/commit.c
+++ /tmp/cocci-output-206241-02f1a7-commit.c
@@ -233,8 +233,8 @@ static int list_paths(struct string_list
 		free(max_prefix);
 	}
 
-	for (i = 0; i < active_nr; i++) {
-		const struct cache_entry *ce = active_cache[i];
+	for (i = 0; i < the_index.cache_nr; i++) {
+		const struct cache_entry *ce = the_index.cache[i];
 		struct string_list_item *item;
 
 		if (ce->ce_flags & CE_UPDATE)
@@ -263,10 +263,10 @@ static void add_remove_files(struct stri
 			continue;
 
 		if (!lstat(p->string, &st)) {
-			if (add_to_cache(p->string, &st, 0))
+			if (add_to_index(&the_index, p->string, &st, 0))
 				die(_("updating files failed"));
 		} else
-			remove_file_from_cache(p->string);
+			remove_file_from_index(&the_index, p->string);
 	}
 }
 
@@ -277,7 +277,7 @@ static void create_base_index(const stru
 	struct tree_desc t;
 
 	if (!current_head) {
-		discard_cache();
+		discard_index(&the_index);
 		return;
 	}
 
@@ -304,7 +304,7 @@ static void refresh_cache_or_die(int ref
 	 * refresh_flags contains REFRESH_QUIET, so the only errors
 	 * are for unmerged entries.
 	 */
-	if (refresh_cache(refresh_flags | REFRESH_IN_PORCELAIN))
+	if (refresh_index(&the_index, refresh_flags | REFRESH_IN_PORCELAIN, NULL, NULL, NULL))
 		die_resolve_conflict("commit");
 }
 
@@ -322,7 +322,7 @@ static const char *prepare_index(int arg
 		       PATHSPEC_PREFER_FULL,
 		       prefix, argv);
 
-	if (read_cache_preload(&pathspec) < 0)
+	if (read_index_preload(&the_index, &pathspec) < 0)
 		die(_("index file corrupt"));
 
 	if (interactive) {
@@ -345,8 +345,9 @@ static const char *prepare_index(int arg
 		else
 			unsetenv(INDEX_ENVIRONMENT);
 
-		discard_cache();
-		read_cache_from(get_lock_file_path(&index_lock));
+		discard_index(&the_index);
+		read_index_from(&the_index, get_lock_file_path(&index_lock),
+				get_git_dir());
 		if (update_main_cache_tree(WRITE_TREE_SILENT) == 0) {
 			if (reopen_lock_file(&index_lock) < 0)
 				die(_("unable to write index file"));
@@ -396,8 +397,8 @@ static const char *prepare_index(int arg
 	if (!only && !pathspec.nr) {
 		hold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);
 		refresh_cache_or_die(refresh_flags);
-		if (active_cache_changed
-		    || !cache_tree_fully_valid(active_cache_tree))
+		if (the_index.cache_changed
+		    || !cache_tree_fully_valid(the_index.cache_tree))
 			update_main_cache_tree(WRITE_TREE_SILENT);
 		if (write_locked_index(&the_index, &index_lock,
 				       COMMIT_LOCK | SKIP_IF_UNCHANGED))
@@ -438,13 +439,13 @@ static const char *prepare_index(int arg
 	if (list_paths(&partial, !current_head ? NULL : "HEAD", prefix, &pathspec))
 		exit(1);
 
-	discard_cache();
-	if (read_cache() < 0)
+	discard_index(&the_index);
+	if (read_index(&the_index) < 0)
 		die(_("cannot read the index"));
 
 	hold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);
 	add_remove_files(&partial);
-	refresh_cache(REFRESH_QUIET);
+	refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 	update_main_cache_tree(WRITE_TREE_SILENT);
 	if (write_locked_index(&the_index, &index_lock, 0))
 		die(_("unable to write new_index file"));
@@ -456,14 +457,14 @@ static const char *prepare_index(int arg
 
 	create_base_index(current_head);
 	add_remove_files(&partial);
-	refresh_cache(REFRESH_QUIET);
+	refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 
 	if (write_locked_index(&the_index, &false_lock, 0))
 		die(_("unable to write temporary index file"));
 
-	discard_cache();
+	discard_index(&the_index);
 	ret = get_lock_file_path(&false_lock);
-	read_cache_from(ret);
+	read_index_from(&the_index, ret, get_git_dir());
 out:
 	string_list_clear(&partial, 0);
 	clear_pathspec(&pathspec);
@@ -864,7 +865,7 @@ static int prepare_to_commit(const char
 		struct object_id oid;
 		const char *parent = "HEAD";
 
-		if (!active_nr && read_cache() < 0)
+		if (!the_index.cache_nr && read_index(&the_index) < 0)
 			die(_("Cannot read index"));
 
 		if (amend)
@@ -873,10 +874,10 @@ static int prepare_to_commit(const char
 		if (get_oid(parent, &oid)) {
 			int i, ita_nr = 0;
 
-			for (i = 0; i < active_nr; i++)
-				if (ce_intent_to_add(active_cache[i]))
+			for (i = 0; i < the_index.cache_nr; i++)
+				if (ce_intent_to_add(the_index.cache[i]))
 					ita_nr++;
-			commitable = active_nr - ita_nr > 0;
+			commitable = the_index.cache_nr - ita_nr > 0;
 		} else {
 			/*
 			 * Unless the user did explicitly request a submodule
@@ -926,9 +927,9 @@ static int prepare_to_commit(const char
 		 * and write it out as a tree.  We must do this before we invoke
 		 * the editor and after we invoke run_status above.
 		 */
-		discard_cache();
+		discard_index(&the_index);
 	}
-	read_cache_from(index_file);
+	read_index_from(&the_index, index_file, get_git_dir());
 
 	if (update_main_cache_tree(0)) {
 		error(_("Error building trees"));
--- builtin/diff-files.c
+++ /tmp/cocci-output-206251-46b008-diff-files.c
@@ -66,7 +66,7 @@ int cmd_diff_files(int argc, const char
 	    (rev.diffopt.output_format & DIFF_FORMAT_PATCH))
 		rev.combine_merges = rev.dense_combined_merges = 1;
 
-	if (read_cache_preload(&rev.diffopt.pathspec) < 0) {
+	if (read_index_preload(&the_index, &rev.diffopt.pathspec) < 0) {
 		perror("read_cache_preload");
 		return -1;
 	}
--- builtin/diff-index.c
+++ /tmp/cocci-output-206256-83e320-diff-index.c
@@ -48,11 +48,11 @@ int cmd_diff_index(int argc, const char
 		usage(diff_cache_usage);
 	if (!cached) {
 		setup_work_tree();
-		if (read_cache_preload(&rev.diffopt.pathspec) < 0) {
+		if (read_index_preload(&the_index, &rev.diffopt.pathspec) < 0) {
 			perror("read_cache_preload");
 			return -1;
 		}
-	} else if (read_cache() < 0) {
+	} else if (read_index(&the_index) < 0) {
 		perror("read_cache");
 		return -1;
 	}
--- builtin/diff-tree.c
+++ /tmp/cocci-output-206261-e5cd9c-diff-tree.c
@@ -111,7 +111,7 @@ int cmd_diff_tree(int argc, const char *
 
 	git_config(git_diff_basic_config, NULL); /* no "diff" UI options */
 	init_revisions(opt, the_repository, prefix);
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 	opt->abbrev = 0;
 	opt->diff = 1;
--- builtin/diff.c
+++ /tmp/cocci-output-206266-07f964-diff.c
@@ -146,11 +146,11 @@ static int builtin_diff_index(struct rev
 		usage(builtin_diff_usage);
 	if (!cached) {
 		setup_work_tree();
-		if (read_cache_preload(&revs->diffopt.pathspec) < 0) {
+		if (read_index_preload(&the_index, &revs->diffopt.pathspec) < 0) {
 			perror("read_cache_preload");
 			return -1;
 		}
-	} else if (read_cache() < 0) {
+	} else if (read_index(&the_index) < 0) {
 		perror("read_cache");
 		return -1;
 	}
@@ -211,9 +211,10 @@ static void refresh_index_quietly(void)
 	fd = hold_locked_index(&lock_file, 0);
 	if (fd < 0)
 		return;
-	discard_cache();
-	read_cache();
-	refresh_cache(REFRESH_QUIET|REFRESH_UNMERGED);
+	discard_index(&the_index);
+	read_index(&the_index);
+	refresh_index(&the_index, REFRESH_QUIET | REFRESH_UNMERGED, NULL,
+		      NULL, NULL);
 	repo_update_index_if_able(the_repository, &lock_file);
 }
 
@@ -248,7 +249,7 @@ static int builtin_diff_files(struct rev
 		revs->combine_merges = revs->dense_combined_merges = 1;
 
 	setup_work_tree();
-	if (read_cache_preload(&revs->diffopt.pathspec) < 0) {
+	if (read_index_preload(&the_index, &revs->diffopt.pathspec) < 0) {
 		perror("read_cache_preload");
 		return -1;
 	}
--- builtin/fsck.c
+++ /tmp/cocci-output-206277-317c6c-fsck.c
@@ -798,16 +798,16 @@ int cmd_fsck(int argc, const char **argv
 	if (keep_cache_objects) {
 		verify_index_checksum = 1;
 		verify_ce_order = 1;
-		read_cache();
-		for (i = 0; i < active_nr; i++) {
+		read_index(&the_index);
+		for (i = 0; i < the_index.cache_nr; i++) {
 			unsigned int mode;
 			struct blob *blob;
 			struct object *obj;
 
-			mode = active_cache[i]->ce_mode;
+			mode = the_index.cache[i]->ce_mode;
 			if (S_ISGITLINK(mode))
 				continue;
-			blob = lookup_blob(&active_cache[i]->oid);
+			blob = lookup_blob(&the_index.cache[i]->oid);
 			if (!blob)
 				continue;
 			obj = &blob->object;
@@ -815,11 +815,11 @@ int cmd_fsck(int argc, const char **argv
 			if (name_objects)
 				add_decoration(fsck_walk_options.object_names,
 					obj,
-					xstrfmt(":%s", active_cache[i]->name));
+					xstrfmt(":%s", the_index.cache[i]->name));
 			mark_object_reachable(obj);
 		}
-		if (active_cache_tree)
-			fsck_cache_tree(active_cache_tree);
+		if (the_index.cache_tree)
+			fsck_cache_tree(the_index.cache_tree);
 	}
 
 	check_connectivity();
--- builtin/merge.c
+++ /tmp/cocci-output-206296-4e0c70-merge.c
@@ -338,7 +338,7 @@ static void restore_state(const struct o
 	run_command_v_opt(args, RUN_GIT_CMD);
 
 	strbuf_release(&sb);
-	refresh_cache(REFRESH_QUIET);
+	refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 }
 
 /* This is called when no merge was necessary. */
@@ -630,7 +630,7 @@ static int read_tree_trivial(struct obje
 	if (!trees[nr_trees++])
 		return -1;
 	opts.fn = threeway_merge;
-	cache_tree_free(&active_cache_tree);
+	cache_tree_free(&the_index.cache_tree);
 	for (i = 0; i < nr_trees; i++) {
 		parse_tree(trees[i]);
 		init_tree_desc(t+i, trees[i]->buffer, trees[i]->size);
@@ -654,7 +654,7 @@ static int try_merge_strategy(const char
 	const char *head_arg = "HEAD";
 
 	hold_locked_index(&lock, LOCK_DIE_ON_ERROR);
-	refresh_cache(REFRESH_QUIET);
+	refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 	if (write_locked_index(&the_index, &lock,
 			       COMMIT_LOCK | SKIP_IF_UNCHANGED))
 		return error(_("Unable to write index."));
@@ -717,8 +717,8 @@ static int count_unmerged_entries(void)
 {
 	int i, ret = 0;
 
-	for (i = 0; i < active_nr; i++)
-		if (ce_stage(active_cache[i]))
+	for (i = 0; i < the_index.cache_nr; i++)
+		if (ce_stage(the_index.cache[i]))
 			ret++;
 
 	return ret;
@@ -812,7 +812,7 @@ static int merge_trivial(struct commit *
 	struct lock_file lock = LOCK_INIT;
 
 	hold_locked_index(&lock, LOCK_DIE_ON_ERROR);
-	refresh_cache(REFRESH_QUIET);
+	refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 	if (write_locked_index(&the_index, &lock,
 			       COMMIT_LOCK | SKIP_IF_UNCHANGED))
 		return error(_("Unable to write index."));
@@ -1237,7 +1237,7 @@ int cmd_merge(int argc, const char **arg
 		goto done;
 	}
 
-	if (read_cache_unmerged())
+	if (read_index_unmerged(&the_index))
 		die_resolve_conflict("merge");
 
 	if (file_exists(git_path_merge_head())) {
@@ -1258,7 +1258,7 @@ int cmd_merge(int argc, const char **arg
 		else
 			die(_("You have not concluded your cherry-pick (CHERRY_PICK_HEAD exists)."));
 	}
-	resolve_undo_clear();
+	resolve_undo_clear_index(&the_index);
 
 	if (verbosity < 0)
 		show_diffstat = 0;
@@ -1458,7 +1458,7 @@ int cmd_merge(int argc, const char **arg
 		 * We are not doing octopus, not fast-forward, and have
 		 * only one common.
 		 */
-		refresh_cache(REFRESH_QUIET);
+		refresh_index(&the_index, REFRESH_QUIET, NULL, NULL, NULL);
 		if (allow_trivial && fast_forward != FF_ONLY) {
 			/* See if it is really trivial. */
 			git_committer_info(IDENT_STRICT);
--- builtin/merge-index.c
+++ /tmp/cocci-output-206303-7bfaf2-merge-index.c
@@ -13,11 +13,11 @@ static int merge_entry(int pos, const ch
 	char hexbuf[4][GIT_MAX_HEXSZ + 1];
 	char ownbuf[4][60];
 
-	if (pos >= active_nr)
+	if (pos >= the_index.cache_nr)
 		die("git merge-index: %s not in the cache", path);
 	found = 0;
 	do {
-		const struct cache_entry *ce = active_cache[pos];
+		const struct cache_entry *ce = the_index.cache[pos];
 		int stage = ce_stage(ce);
 
 		if (strcmp(ce->name, path))
@@ -27,7 +27,7 @@ static int merge_entry(int pos, const ch
 		xsnprintf(ownbuf[stage], sizeof(ownbuf[stage]), "%o", ce->ce_mode);
 		arguments[stage] = hexbuf[stage];
 		arguments[stage + 4] = ownbuf[stage];
-	} while (++pos < active_nr);
+	} while (++pos < the_index.cache_nr);
 	if (!found)
 		die("git merge-index: %s not in the cache", path);
 
@@ -45,7 +45,7 @@ static int merge_entry(int pos, const ch
 
 static void merge_one_path(const char *path)
 {
-	int pos = cache_name_pos(path, strlen(path));
+	int pos = index_name_pos(&the_index, path, strlen(path));
 
 	/*
 	 * If it already exists in the cache as stage0, it's
@@ -58,8 +58,8 @@ static void merge_one_path(const char *p
 static void merge_all(void)
 {
 	int i;
-	for (i = 0; i < active_nr; i++) {
-		const struct cache_entry *ce = active_cache[i];
+	for (i = 0; i < the_index.cache_nr; i++) {
+		const struct cache_entry *ce = the_index.cache[i];
 		if (!ce_stage(ce))
 			continue;
 		i += merge_entry(i, ce->name)-1;
@@ -78,7 +78,7 @@ int cmd_merge_index(int argc, const char
 	if (argc < 3)
 		usage("git merge-index [-o] [-q] <merge-program> (-a | [--] [<filename>...])");
 
-	read_cache();
+	read_index(&the_index);
 
 	i = 1;
 	if (!strcmp(argv[i], "-o")) {
--- builtin/merge-ours.c
+++ /tmp/cocci-output-206308-f9d113-merge-ours.c
@@ -25,7 +25,7 @@ int cmd_merge_ours(int argc, const char
 	 * commit.  The index must match HEAD, or this merge cannot go
 	 * through.
 	 */
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die_errno("read_cache failed");
 	if (index_differs_from("HEAD", NULL, 0))
 		exit(2);
--- builtin/mv.c
+++ /tmp/cocci-output-206317-dcc551-mv.c
@@ -79,7 +79,7 @@ static void prepare_move_submodule(const
 				   const char **submodule_gitfile)
 {
 	struct strbuf submodule_dotgit = STRBUF_INIT;
-	if (!S_ISGITLINK(active_cache[first]->ce_mode))
+	if (!S_ISGITLINK(the_index.cache[first]->ce_mode))
 		die(_("Directory %s is in index and no submodule?"), src);
 	if (!is_staging_gitmodules_ok(&the_index))
 		die(_("Please stage your changes to .gitmodules or stash them to proceed"));
@@ -98,13 +98,13 @@ static int index_range_of_same_dir(const
 	const char *src_w_slash = add_slash(src);
 	int first, last, len_w_slash = length + 1;
 
-	first = cache_name_pos(src_w_slash, len_w_slash);
+	first = index_name_pos(&the_index, src_w_slash, len_w_slash);
 	if (first >= 0)
 		die(_("%.*s is in index"), len_w_slash, src_w_slash);
 
 	first = -1 - first;
-	for (last = first; last < active_nr; last++) {
-		const char *path = active_cache[last]->name;
+	for (last = first; last < the_index.cache_nr; last++) {
+		const char *path = the_index.cache[last]->name;
 		if (strncmp(path, src_w_slash, len_w_slash))
 			break;
 	}
@@ -141,7 +141,7 @@ int cmd_mv(int argc, const char **argv,
 		usage_with_options(builtin_mv_usage, builtin_mv_options);
 
 	hold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 
 	source = internal_prefix_pathspec(prefix, argv, argc, 0);
@@ -189,7 +189,7 @@ int cmd_mv(int argc, const char **argv,
 				&& lstat(dst, &st) == 0)
 			bad = _("cannot move directory over file");
 		else if (src_is_dir) {
-			int first = cache_name_pos(src, length), last;
+			int first = index_name_pos(&the_index, src, length), last;
 
 			if (first >= 0)
 				prepare_move_submodule(src, first,
@@ -211,7 +211,7 @@ int cmd_mv(int argc, const char **argv,
 				dst_len = strlen(dst);
 
 				for (j = 0; j < last - first; j++) {
-					const char *path = active_cache[first + j]->name;
+					const char *path = the_index.cache[first + j]->name;
 					source[argc + j] = path;
 					destination[argc + j] =
 						prefix_path(dst, dst_len, path + length + 1);
@@ -220,7 +220,7 @@ int cmd_mv(int argc, const char **argv,
 				}
 				argc += last - first;
 			}
-		} else if (cache_name_pos(src, length) < 0)
+		} else if (index_name_pos(&the_index, src, length) < 0)
 			bad = _("not under version control");
 		else if (lstat(dst, &st) == 0 &&
 			 (!ignore_case || strcasecmp(src, dst))) {
@@ -288,9 +288,9 @@ int cmd_mv(int argc, const char **argv,
 		if (mode == WORKING_DIRECTORY)
 			continue;
 
-		pos = cache_name_pos(src, strlen(src));
+		pos = index_name_pos(&the_index, src, strlen(src));
 		assert(pos >= 0);
-		rename_cache_entry_at(pos, dst);
+		rename_index_entry_at(&the_index, pos, dst);
 	}
 
 	if (gitmodules_modified)
--- builtin/pull.c
+++ /tmp/cocci-output-206330-aaaaf5-pull.c
@@ -864,7 +864,7 @@ int cmd_pull(int argc, const char **argv
 	if (opt_rebase < 0)
 		opt_rebase = config_get_rebase();
 
-	if (read_cache_unmerged())
+	if (read_index_unmerged(&the_index))
 		die_resolve_conflict("pull");
 
 	if (file_exists(git_path_merge_head()))
@@ -881,7 +881,7 @@ int cmd_pull(int argc, const char **argv
 		if (opt_autostash != -1)
 			autostash = opt_autostash;
 
-		if (is_null_oid(&orig_head) && !is_cache_unborn())
+		if (is_null_oid(&orig_head) && !is_index_unborn(&the_index))
 			die(_("Updating an unborn branch with changes added to the index."));
 
 		if (!autostash)
--- builtin/read-tree.c
+++ /tmp/cocci-output-206336-40b38a-read-tree.c
@@ -180,11 +180,11 @@ int cmd_read_tree(int argc, const char *
 	 */
 
 	if (opts.reset || opts.merge || opts.prefix) {
-		if (read_cache_unmerged() && (opts.prefix || opts.merge))
+		if (read_index_unmerged(&the_index) && (opts.prefix || opts.merge))
 			die("You need to resolve your current index first");
 		stage = opts.merge = 1;
 	}
-	resolve_undo_clear();
+	resolve_undo_clear_index(&the_index);
 
 	for (i = 0; i < argc; i++) {
 		const char *arg = argv[i];
@@ -220,7 +220,7 @@ int cmd_read_tree(int argc, const char *
 			break;
 		case 2:
 			opts.fn = twoway_merge;
-			opts.initial_checkout = is_cache_unborn();
+			opts.initial_checkout = is_index_unborn(&the_index);
 			break;
 		case 3:
 		default:
@@ -237,7 +237,7 @@ int cmd_read_tree(int argc, const char *
 	if (opts.debug_unpack)
 		opts.fn = debug_merge;
 
-	cache_tree_free(&active_cache_tree);
+	cache_tree_free(&the_index.cache_tree);
 	for (i = 0; i < nr_trees; i++) {
 		struct tree *tree = trees[i];
 		parse_tree(tree);
--- builtin/reset.c
+++ /tmp/cocci-output-206350-640828-reset.c
@@ -71,7 +71,7 @@ static int reset_index(const struct obje
 		opts.reset = 1;
 	}
 
-	read_cache_unmerged();
+	read_index_unmerged(&the_index);
 
 	if (reset_type == KEEP) {
 		struct object_id head_oid;
@@ -131,7 +131,7 @@ static void update_index_from_diff(struc
 		struct cache_entry *ce;
 
 		if (is_missing && !intent_to_add) {
-			remove_file_from_cache(one->path);
+			remove_file_from_index(&the_index, one->path);
 			continue;
 		}
 
@@ -144,7 +144,8 @@ static void update_index_from_diff(struc
 			ce->ce_flags |= CE_INTENT_TO_ADD;
 			set_object_name_for_intent_to_add_entry(ce);
 		}
-		add_cache_entry(ce, ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);
+		add_index_entry(&the_index, ce,
+				ADD_CACHE_OK_TO_ADD | ADD_CACHE_OK_TO_REPLACE);
 	}
 }
 
@@ -187,7 +188,7 @@ static void set_reflog_message(struct st
 
 static void die_if_unmerged_cache(int reset_type)
 {
-	if (is_merge() || unmerged_cache())
+	if (is_merge() || unmerged_index(&the_index))
 		die(_("Cannot do a %s reset in the middle of a merge."),
 		    _(reset_type_names[reset_type]));
 
@@ -239,7 +240,7 @@ static void parse_args(struct pathspec *
 	}
 	*rev_ret = rev;
 
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 
 	parse_pathspec(pathspec, 0,
--- builtin/rev-parse.c
+++ /tmp/cocci-output-206356-b7ba64-rev-parse.c
@@ -889,7 +889,7 @@ int cmd_rev_parse(int argc, const char *
 				continue;
 			}
 			if (!strcmp(arg, "--shared-index-path")) {
-				if (read_cache() < 0)
+				if (read_index(&the_index) < 0)
 					die(_("Could not read the index"));
 				if (the_index.split_index) {
 					const struct object_id *oid = &the_index.split_index->base_oid;
--- builtin/rm.c
+++ /tmp/cocci-output-206362-a79cb3-rm.c
@@ -32,8 +32,8 @@ static int get_ours_cache_pos(const char
 {
 	int i = -pos - 1;
 
-	while ((i < active_nr) && !strcmp(active_cache[i]->name, path)) {
-		if (ce_stage(active_cache[i]) == 2)
+	while ((i < the_index.cache_nr) && !strcmp(the_index.cache[i]->name, path)) {
+		if (ce_stage(the_index.cache[i]) == 2)
 			return i;
 		i++;
 	}
@@ -69,13 +69,13 @@ static void submodules_absorb_gitdir_if_
 		int pos;
 		const struct cache_entry *ce;
 
-		pos = cache_name_pos(name, strlen(name));
+		pos = index_name_pos(&the_index, name, strlen(name));
 		if (pos < 0) {
 			pos = get_ours_cache_pos(name, pos);
 			if (pos < 0)
 				continue;
 		}
-		ce = active_cache[pos];
+		ce = the_index.cache[pos];
 
 		if (!S_ISGITLINK(ce->ce_mode) ||
 		    !file_exists(ce->name) ||
@@ -114,7 +114,7 @@ static int check_local_mod(struct object
 		int local_changes = 0;
 		int staged_changes = 0;
 
-		pos = cache_name_pos(name, strlen(name));
+		pos = index_name_pos(&the_index, name, strlen(name));
 		if (pos < 0) {
 			/*
 			 * Skip unmerged entries except for populated submodules
@@ -124,11 +124,11 @@ static int check_local_mod(struct object
 			if (pos < 0)
 				continue;
 
-			if (!S_ISGITLINK(active_cache[pos]->ce_mode) ||
+			if (!S_ISGITLINK(the_index.cache[pos]->ce_mode) ||
 			    is_empty_dir(name))
 				continue;
 		}
-		ce = active_cache[pos];
+		ce = the_index.cache[pos];
 
 		if (lstat(ce->name, &st) < 0) {
 			if (!is_missing_file_error(errno))
@@ -165,7 +165,7 @@ static int check_local_mod(struct object
 		 * Is the index different from the file in the work tree?
 		 * If it's a submodule, is its work tree modified?
 		 */
-		if (ce_match_stat(ce, &st, 0) ||
+		if (ie_match_stat(&the_index, ce, &st, 0) ||
 		    (S_ISGITLINK(ce->ce_mode) &&
 		     bad_to_remove_submodule(ce->name,
 				SUBMODULE_REMOVAL_DIE_ON_ERROR |
@@ -267,7 +267,7 @@ int cmd_rm(int argc, const char **argv,
 
 	hold_locked_index(&lock_file, LOCK_DIE_ON_ERROR);
 
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 
 	parse_pathspec(&pathspec, 0,
@@ -277,8 +277,8 @@ int cmd_rm(int argc, const char **argv,
 
 	seen = xcalloc(pathspec.nr, 1);
 
-	for (i = 0; i < active_nr; i++) {
-		const struct cache_entry *ce = active_cache[i];
+	for (i = 0; i < the_index.cache_nr; i++) {
+		const struct cache_entry *ce = the_index.cache[i];
 		if (!ce_path_match(&the_index, ce, &pathspec, seen))
 			continue;
 		ALLOC_GROW(list.entry, list.nr + 1, list.alloc);
@@ -342,7 +342,7 @@ int cmd_rm(int argc, const char **argv,
 		if (!quiet)
 			printf("rm '%s'\n", path);
 
-		if (remove_file_from_cache(path))
+		if (remove_file_from_index(&the_index, path))
 			die(_("git rm: unable to remove %s"), path);
 	}
 
--- builtin/submodule--helper.c
+++ /tmp/cocci-output-206373-deb7ed-submodule--helper.c
@@ -325,11 +325,11 @@ static int module_list_compute(int argc,
 	if (pathspec->nr)
 		ps_matched = xcalloc(pathspec->nr, 1);
 
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die(_("index file corrupt"));
 
-	for (i = 0; i < active_nr; i++) {
-		const struct cache_entry *ce = active_cache[i];
+	for (i = 0; i < the_index.cache_nr; i++) {
+		const struct cache_entry *ce = the_index.cache[i];
 
 		if (!match_pathspec(&the_index, pathspec, ce->name, ce_namelen(ce),
 				    0, ps_matched, 1) ||
@@ -338,8 +338,8 @@ static int module_list_compute(int argc,
 
 		ALLOC_GROW(list->entries, list->nr + 1, list->alloc);
 		list->entries[list->nr++] = ce;
-		while (i + 1 < active_nr &&
-		       !strcmp(ce->name, active_cache[i + 1]->name))
+		while (i + 1 < the_index.cache_nr &&
+		       !strcmp(ce->name, the_index.cache[i + 1]->name))
 			/*
 			 * Skip entries with the same name in different stages
 			 * to make sure an entry is returned only once.
--- builtin/update-index.c
+++ /tmp/cocci-output-206382-a11b11-update-index.c
@@ -229,16 +229,16 @@ done:
 static int mark_ce_flags(const char *path, int flag, int mark)
 {
 	int namelen = strlen(path);
-	int pos = cache_name_pos(path, namelen);
+	int pos = index_name_pos(&the_index, path, namelen);
 	if (0 <= pos) {
-		mark_fsmonitor_invalid(&the_index, active_cache[pos]);
+		mark_fsmonitor_invalid(&the_index, the_index.cache[pos]);
 		if (mark)
-			active_cache[pos]->ce_flags |= flag;
+			the_index.cache[pos]->ce_flags |= flag;
 		else
-			active_cache[pos]->ce_flags &= ~flag;
-		active_cache[pos]->ce_flags |= CE_UPDATE_IN_BASE;
+			the_index.cache[pos]->ce_flags &= ~flag;
+		the_index.cache[pos]->ce_flags |= CE_UPDATE_IN_BASE;
 		cache_tree_invalidate_path(&the_index, path);
-		active_cache_changed |= CE_ENTRY_CHANGED;
+		the_index.cache_changed |= CE_ENTRY_CHANGED;
 		return 0;
 	}
 	return -1;
@@ -248,7 +248,7 @@ static int remove_one_path(const char *p
 {
 	if (!allow_remove)
 		return error("%s: does not exist and --remove not passed", path);
-	if (remove_file_from_cache(path))
+	if (remove_file_from_index(&the_index, path))
 		return error("%s: cannot remove from the index", path);
 	return 0;
 }
@@ -273,7 +273,7 @@ static int add_one_path(const struct cac
 	struct cache_entry *ce;
 
 	/* Was the old index entry already up-to-date? */
-	if (old && !ce_stage(old) && !ce_match_stat(old, st, 0))
+	if (old && !ce_stage(old) && !ie_match_stat(&the_index, old, st, 0))
 		return 0;
 
 	size = cache_entry_size(len);
@@ -291,7 +291,7 @@ static int add_one_path(const struct cac
 	}
 	option = allow_add ? ADD_CACHE_OK_TO_ADD : 0;
 	option |= allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0;
-	if (add_cache_entry(ce, option)) {
+	if (add_index_entry(&the_index, ce, option)) {
 		free(ce);
 		return error("%s: cannot add to the index - missing --add option?", path);
 	}
@@ -324,11 +324,11 @@ static int add_one_path(const struct cac
 static int process_directory(const char *path, int len, struct stat *st)
 {
 	struct object_id oid;
-	int pos = cache_name_pos(path, len);
+	int pos = index_name_pos(&the_index, path, len);
 
 	/* Exact match: file or existing gitlink */
 	if (pos >= 0) {
-		const struct cache_entry *ce = active_cache[pos];
+		const struct cache_entry *ce = the_index.cache[pos];
 		if (S_ISGITLINK(ce->ce_mode)) {
 
 			/* Do nothing to the index if there is no HEAD! */
@@ -343,8 +343,8 @@ static int process_directory(const char
 
 	/* Inexact match: is there perhaps a subdirectory match? */
 	pos = -pos-1;
-	while (pos < active_nr) {
-		const struct cache_entry *ce = active_cache[pos++];
+	while (pos < the_index.cache_nr) {
+		const struct cache_entry *ce = the_index.cache[pos++];
 
 		if (strncmp(ce->name, path, len))
 			break;
@@ -374,15 +374,15 @@ static int process_path(const char *path
 	if (has_symlink_leading_path(path, len))
 		return error("'%s' is beyond a symbolic link", path);
 
-	pos = cache_name_pos(path, len);
-	ce = pos < 0 ? NULL : active_cache[pos];
+	pos = index_name_pos(&the_index, path, len);
+	ce = pos < 0 ? NULL : the_index.cache[pos];
 	if (ce && ce_skip_worktree(ce)) {
 		/*
 		 * working directory version is assumed "good"
 		 * so updating it does not make sense.
 		 * On the other hand, removing it from index should work
 		 */
-		if (allow_remove && remove_file_from_cache(path))
+		if (allow_remove && remove_file_from_index(&the_index, path))
 			return error("%s: cannot remove from the index", path);
 		return 0;
 	}
@@ -422,7 +422,7 @@ static int add_cacheinfo(unsigned int mo
 		ce->ce_flags |= CE_VALID;
 	option = allow_add ? ADD_CACHE_OK_TO_ADD : 0;
 	option |= allow_replace ? ADD_CACHE_OK_TO_REPLACE : 0;
-	if (add_cache_entry(ce, option))
+	if (add_index_entry(&the_index, ce, option))
 		return error("%s: cannot add to the index - missing --add option?",
 			     path);
 	report("add '%s'", path);
@@ -434,11 +434,11 @@ static void chmod_path(char flip, const
 	int pos;
 	struct cache_entry *ce;
 
-	pos = cache_name_pos(path, strlen(path));
+	pos = index_name_pos(&the_index, path, strlen(path));
 	if (pos < 0)
 		goto fail;
-	ce = active_cache[pos];
-	if (chmod_cache_entry(ce, flip) < 0)
+	ce = the_index.cache[pos];
+	if (chmod_index_entry(&the_index, ce, flip) < 0)
 		goto fail;
 
 	report("chmod %cx '%s'", flip, path);
@@ -481,7 +481,7 @@ static void update_one(const char *path)
 	}
 
 	if (force_remove) {
-		if (remove_file_from_cache(path))
+		if (remove_file_from_index(&the_index, path))
 			die("git update-index: unable to remove %s", path);
 		report("remove '%s'", path);
 		return;
@@ -563,7 +563,7 @@ static void read_index_info(int nul_term
 
 		if (!mode) {
 			/* mode == 0 means there is no such path -- remove */
-			if (remove_file_from_cache(path_name))
+			if (remove_file_from_index(&the_index, path_name))
 				die("git update-index: unable to remove %s",
 				    ptr);
 		}
@@ -632,12 +632,12 @@ static int unresolve_one(const char *pat
 	struct cache_entry *ce_2 = NULL, *ce_3 = NULL;
 
 	/* See if there is such entry in the index. */
-	pos = cache_name_pos(path, namelen);
+	pos = index_name_pos(&the_index, path, namelen);
 	if (0 <= pos) {
 		/* already merged */
-		pos = unmerge_cache_entry_at(pos);
-		if (pos < active_nr) {
-			const struct cache_entry *ce = active_cache[pos];
+		pos = unmerge_index_entry_at(&the_index, pos);
+		if (pos < the_index.cache_nr) {
+			const struct cache_entry *ce = the_index.cache[pos];
 			if (ce_stage(ce) &&
 			    ce_namelen(ce) == namelen &&
 			    !memcmp(ce->name, path, namelen))
@@ -650,8 +650,8 @@ static int unresolve_one(const char *pat
 		 * want to do anything in the former case.
 		 */
 		pos = -pos-1;
-		if (pos < active_nr) {
-			const struct cache_entry *ce = active_cache[pos];
+		if (pos < the_index.cache_nr) {
+			const struct cache_entry *ce = the_index.cache[pos];
 			if (ce_namelen(ce) == namelen &&
 			    !memcmp(ce->name, path, namelen)) {
 				fprintf(stderr,
@@ -680,13 +680,13 @@ static int unresolve_one(const char *pat
 		goto free_return;
 	}
 
-	remove_file_from_cache(path);
-	if (add_cache_entry(ce_2, ADD_CACHE_OK_TO_ADD)) {
+	remove_file_from_index(&the_index, path);
+	if (add_index_entry(&the_index, ce_2, ADD_CACHE_OK_TO_ADD)) {
 		error("%s: cannot add our version to the index.", path);
 		ret = -1;
 		goto free_return;
 	}
-	if (!add_cache_entry(ce_3, ADD_CACHE_OK_TO_ADD))
+	if (!add_index_entry(&the_index, ce_3, ADD_CACHE_OK_TO_ADD))
 		return 0;
 	error("%s: cannot add their version to the index.", path);
 	ret = -1;
@@ -746,8 +746,8 @@ static int do_reupdate(int ac, const cha
 		 */
 		has_head = 0;
  redo:
-	for (pos = 0; pos < active_nr; pos++) {
-		const struct cache_entry *ce = active_cache[pos];
+	for (pos = 0; pos < the_index.cache_nr; pos++) {
+		const struct cache_entry *ce = the_index.cache[pos];
 		struct cache_entry *old = NULL;
 		int save_nr;
 		char *path;
@@ -766,12 +766,12 @@ static int do_reupdate(int ac, const cha
 		 * path anymore, in which case, under 'allow_remove',
 		 * or worse yet 'allow_replace', active_nr may decrease.
 		 */
-		save_nr = active_nr;
+		save_nr = the_index.cache_nr;
 		path = xstrdup(ce->name);
 		update_one(path);
 		free(path);
 		free(old);
-		if (save_nr != active_nr)
+		if (save_nr != the_index.cache_nr)
 			goto redo;
 	}
 	clear_pathspec(&pathspec);
@@ -786,8 +786,9 @@ struct refresh_params {
 static int refresh(struct refresh_params *o, unsigned int flag)
 {
 	setup_work_tree();
-	read_cache_preload(NULL);
-	*o->has_errors |= refresh_cache(o->flags | flag);
+	read_index_preload(&the_index, NULL);
+	*o->has_errors |= refresh_index(&the_index, o->flags | flag, NULL,
+					NULL, NULL);
 	return 0;
 }
 
@@ -816,7 +817,7 @@ static int chmod_callback(const struct o
 static int resolve_undo_clear_callback(const struct option *opt,
 				const char *arg, int unset)
 {
-	resolve_undo_clear();
+	resolve_undo_clear_index(&the_index);
 	return 0;
 }
 
@@ -900,7 +901,7 @@ static int unresolve_callback(struct par
 	*has_errors = do_unresolve(ctx->argc, ctx->argv,
 				prefix, prefix ? strlen(prefix) : 0);
 	if (*has_errors)
-		active_cache_changed = 0;
+		the_index.cache_changed = 0;
 
 	ctx->argv += ctx->argc - 1;
 	ctx->argc = 1;
@@ -918,7 +919,7 @@ static int reupdate_callback(struct pars
 	*has_errors = do_reupdate(ctx->argc, ctx->argv,
 				prefix, prefix ? strlen(prefix) : 0);
 	if (*has_errors)
-		active_cache_changed = 0;
+		the_index.cache_changed = 0;
 
 	ctx->argv += ctx->argc - 1;
 	ctx->argc = 1;
@@ -1052,7 +1053,7 @@ int cmd_update_index(int argc, const cha
 	if (newfd < 0)
 		lock_error = errno;
 
-	entries = read_cache();
+	entries = read_index(&the_index);
 	if (entries < 0)
 		die("cache corrupted");
 
@@ -1107,7 +1108,7 @@ int cmd_update_index(int argc, const cha
 			    INDEX_FORMAT_LB, INDEX_FORMAT_UB);
 
 		if (the_index.version != preferred_index_format)
-			active_cache_changed |= SOMETHING_CHANGED;
+			the_index.cache_changed |= SOMETHING_CHANGED;
 		the_index.version = preferred_index_format;
 	}
 
@@ -1194,7 +1195,7 @@ int cmd_update_index(int argc, const cha
 		report(_("fsmonitor disabled"));
 	}
 
-	if (active_cache_changed || force_write) {
+	if (the_index.cache_changed || force_write) {
 		if (newfd < 0) {
 			if (refresh_args.flags & REFRESH_QUIET)
 				exit(128);
--- t/helper/test-dump-untracked-cache.c
+++ /tmp/cocci-output-206411-64fa0f-test-dump-untracked-cache.c
@@ -48,7 +48,7 @@ int cmd_main(int ac, const char **av)
 	ignore_untracked_cache_config = 1;
 
 	setup_git_directory();
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die("unable to read index file");
 	uc = the_index.untracked;
 	if (!uc) {
--- t/helper/test-dump-cache-tree.c
+++ /tmp/cocci-output-206428-a636a2-test-dump-cache-tree.c
@@ -60,10 +60,10 @@ int cmd__dump_cache_tree(int ac, const c
 	struct index_state istate;
 	struct cache_tree *another = cache_tree();
 	setup_git_directory();
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die("unable to read index file");
 	istate = the_index;
 	istate.cache_tree = another;
 	cache_tree_update(&istate, WRITE_TREE_DRY_RUN);
-	return dump_cache_tree(active_cache_tree, another, "");
+	return dump_cache_tree(the_index.cache_tree, another, "");
 }
--- t/helper/test-lazy-init-name-hash.c
+++ /tmp/cocci-output-206438-8b586f-test-lazy-init-name-hash.c
@@ -32,7 +32,7 @@ static void dump_run(void)
 	struct dir_entry *dir;
 	struct cache_entry *ce;
 
-	read_cache();
+	read_index(&the_index);
 	if (single) {
 		test_lazy_init_name_hash(&the_index, 0);
 	} else {
@@ -53,7 +53,7 @@ static void dump_run(void)
 		ce = hashmap_iter_next(&iter_cache);
 	}
 
-	discard_cache();
+	discard_index(&the_index);
 }
 
 /*
@@ -70,7 +70,7 @@ static uint64_t time_runs(int try_thread
 
 	for (i = 0; i < count; i++) {
 		t0 = getnanotime();
-		read_cache();
+		read_index(&the_index);
 		t1 = getnanotime();
 		nr_threads_used = test_lazy_init_name_hash(&the_index, try_threaded);
 		t2 = getnanotime();
@@ -93,7 +93,7 @@ static uint64_t time_runs(int try_thread
 				   the_index.cache_nr);
 		fflush(stdout);
 
-		discard_cache();
+		discard_index(&the_index);
 	}
 
 	avg = sum / count;
@@ -117,9 +117,9 @@ static void analyze_run(void)
 	int i;
 	int nr;
 
-	read_cache();
+	read_index(&the_index);
 	cache_nr_limit = the_index.cache_nr;
-	discard_cache();
+	discard_index(&the_index);
 
 	nr = analyze;
 	while (1) {
@@ -132,23 +132,23 @@ static void analyze_run(void)
 			nr = cache_nr_limit;
 
 		for (i = 0; i < count; i++) {
-			read_cache();
+			read_index(&the_index);
 			the_index.cache_nr = nr; /* cheap truncate of index */
 			t1s = getnanotime();
 			test_lazy_init_name_hash(&the_index, 0);
 			t2s = getnanotime();
 			sum_single += (t2s - t1s);
 			the_index.cache_nr = cache_nr_limit;
-			discard_cache();
+			discard_index(&the_index);
 
-			read_cache();
+			read_index(&the_index);
 			the_index.cache_nr = nr; /* cheap truncate of index */
 			t1m = getnanotime();
 			nr_threads_used = test_lazy_init_name_hash(&the_index, 1);
 			t2m = getnanotime();
 			sum_multi += (t2m - t1m);
 			the_index.cache_nr = cache_nr_limit;
-			discard_cache();
+			discard_index(&the_index);
 
 			if (!nr_threads_used)
 				printf("    [size %8d] [single %f]   non-threaded code path used\n",
--- t/helper/test-read-cache.c
+++ /tmp/cocci-output-206449-76a1d5-test-read-cache.c
@@ -8,8 +8,8 @@ int cmd__read_cache(int argc, const char
 		cnt = strtol(argv[1], NULL, 0);
 	setup_git_directory();
 	for (i = 0; i < cnt; i++) {
-		read_cache();
-		discard_cache();
+		read_index(&the_index);
+		discard_index(&the_index);
 	}
 	return 0;
 }
--- t/helper/test-scrap-cache-tree.c
+++ /tmp/cocci-output-206458-4e21e5-test-scrap-cache-tree.c
@@ -10,9 +10,9 @@ int cmd__scrap_cache_tree(int ac, const
 
 	setup_git_directory();
 	hold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);
-	if (read_cache() < 0)
+	if (read_index(&the_index) < 0)
 		die("unable to read index file");
-	active_cache_tree = NULL;
+	the_index.cache_tree = NULL;
 	if (write_locked_index(&the_index, &index_lock, COMMIT_LOCK))
 		die("unable to write index file");
 	return 0;
--- t/helper/test-write-cache.c
+++ /tmp/cocci-output-206472-8a0fe8-test-write-cache.c
@@ -9,7 +9,7 @@ int cmd__write_cache(int argc, const cha
 	if (argc == 2)
 		cnt = strtol(argv[1], NULL, 0);
 	setup_git_directory();
-	read_cache();
+	read_index(&the_index);
 	for (i = 0; i < cnt; i++) {
 		hold_locked_index(&index_lock, LOCK_DIE_ON_ERROR);
 		if (write_locked_index(&the_index, &index_lock, COMMIT_LOCK))
